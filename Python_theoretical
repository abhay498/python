
1. https://www.journaldev.com/23647/python-reverse-string

2. User-defined functions vs. Built-in / Pre-defined functions
   https://stackoverflow.com/questions/17159904/user-defined-functions-vs-built-in-pre-defined-functions

3.   https://docs.python.org/3/glossary.html

4.
 
Algorithm	      Time Complexity	               Space Complexity
               Best	 Average	       Worst	               Worst
Quicksort	   Ω(n log(n))	 Θ(n log(n))	O(n^2)	      O(log(n))
Mergesort	Ω(n log(n))	Θ(n log(n))	O(n log(n))	   O(n)
Heapsort	   Ω(n log(n))	Θ(n log(n))	O(n log(n))	      O(1)
Bubble Sort	Ω(n)	Θ(n^2)	O(n^2)	               O(1)
Insertion Sort	Ω(n)	Θ(n^2)	O(n^2)	            O(1)
Selection Sort	Ω(n^2)	Θ(n^2)	O(n^2)	         O(1)
Cubesort	Ω(n)	Θ(n log(n))	O(n log(n))	            O(n)

4. https://www.python-course.eu/python3_deep_copy.php

5. https://medium.com/@meghamohan/mutable-and-immutable-side-of-python-c2145cf72747

6. https://medium.com/@george.seif94/a-tour-of-the-top-5-sorting-algorithms-with-python-code-43ea9aa02889
    [Sorting algorithms]

7. Built-in String Methods
   
Sr.No.	Methods with Description
1	capitalize()
Capitalizes first letter of string

2	center(width, fillchar)
Returns a space-padded string with the original string centered to a total of width columns.

3	count(str, beg= 0,end=len(string))
Counts how many times str occurs in string or in a substring of string if starting index beg and ending index end are given.

4	decode(encoding='UTF-8',errors='strict')
Decodes the string using the codec registered for encoding. encoding defaults to the default string encoding.

5	encode(encoding='UTF-8',errors='strict')
Returns encoded string version of string; on error, default is to raise a ValueError unless errors is given with 'ignore' or 'replace'.

6	endswith(suffix, beg=0, end=len(string))
Determines if string or a substring of string (if starting index beg and ending index end are given) ends with suffix; returns true if so and false otherwise.

7	expandtabs(tabsize=8)
Expands tabs in string to multiple spaces; defaults to 8 spaces per tab if tabsize not provided.

8	find(str, beg=0 end=len(string))
Determine if str occurs in string or in a substring of string if starting index beg and ending index end are given returns index if found and -1 otherwise.

9	index(str, beg=0, end=len(string))
Same as find(), but raises an exception if str not found.

10	isalnum()
Returns true if string has at least 1 character and all characters are alphanumeric and false otherwise.

11	isalpha()
Returns true if string has at least 1 character and all characters are alphabetic and false otherwise.

12	isdigit()
Returns true if string contains only digits and false otherwise.

13	islower()
Returns true if string has at least 1 cased character and all cased characters are in lowercase and false otherwise.

14	isnumeric()
Returns true if a unicode string contains only numeric characters and false otherwise.

15	isspace()
Returns true if string contains only whitespace characters and false otherwise.

16	istitle()
Returns true if string is properly "titlecased" and false otherwise.

17	isupper()
Returns true if string has at least one cased character and all cased characters are in uppercase and false otherwise.

18	join(seq)
Merges (concatenates) the string representations of elements in sequence seq into a string, with separator string.

19	len(string)
Returns the length of the string

20	ljust(width[, fillchar])
Returns a space-padded string with the original string left-justified to a total of width columns.

21	lower()
Converts all uppercase letters in string to lowercase.

22	lstrip()
Removes all leading whitespace in string.

23	maketrans()
Returns a translation table to be used in translate function.

24	max(str)
Returns the max alphabetical character from the string str.

25	min(str)
Returns the min alphabetical character from the string str.

26	replace(old, new [, max])
Replaces all occurrences of old in string with new or at most max occurrences if max given.

27	rfind(str, beg=0,end=len(string))
Same as find(), but search backwards in string.

28	rindex( str, beg=0, end=len(string))
Same as index(), but search backwards in string.

29	rjust(width,[, fillchar])
Returns a space-padded string with the original string right-justified to a total of width columns.

30	rstrip()
Removes all trailing whitespace of string.

31	split(str="", num=string.count(str))
Splits string according to delimiter str (space if not provided) and returns list of substrings; split into at most num substrings if given.

32	splitlines( num=string.count('\n'))
Splits string at all (or num) NEWLINEs and returns a list of each line with NEWLINEs removed.

33	startswith(str, beg=0,end=len(string))
Determines if string or a substring of string (if starting index beg and ending index end are given) starts with substring str; returns true if so and false otherwise.

34	strip([chars])
Performs both lstrip() and rstrip() on string.

35	swapcase()
Inverts case for all letters in string.

36	title()
Returns "titlecased" version of string, that is, all words begin with uppercase and the rest are lowercase.

37	translate(table, deletechars="")
Translates string according to translation table str(256 chars), removing those in the del string.

38	upper()
Converts lowercase letters in string to uppercase.

39	zfill (width)
Returns original string leftpadded with zeros to a total of width characters; intended for numbers, zfill() retains any sign given (less one zero).

40	isdecimal()
Returns true if a unicode string contains only decimal characters and false otherwise.

8. Built-in List Functions & Methods

Python includes the following list functions −

Sr.No.	Function with Description
1	cmp(list1, list2)
Compares elements of both lists.

2	len(list)
Gives the total length of the list.

3	max(list)
Returns item from the list with max value.

4	min(list)
Returns item from the list with min value.

5	list(seq)
Converts a tuple into list.

Python includes following list methods

Sr.No.	Methods with Description
1	list.append(obj)
Appends object obj to list

2	list.count(obj)
Returns count of how many times obj occurs in list

3	list.extend(seq)
Appends the contents of seq to list

4	list.index(obj)
Returns the lowest index in list that obj appears

5	list.insert(index, obj)
Inserts object obj into list at offset index

6	list.pop(obj=list[-1])
Removes and returns last object or obj from list

7	list.remove(obj)
Removes object obj from list

8	list.reverse()
Reverses objects of list in place

9	list.sort([func])
Sorts objects of list, use compare func if given

9. Built-in Tuple Functions

Python includes the following tuple functions −

1	cmp(tuple1, tuple2)
Compares elements of both tuples.

2	len(tuple)
Gives the total length of the tuple.

3	max(tuple)
Returns item from the tuple with max value.

4	min(tuple)
Returns item from the tuple with min value.

5	tuple(seq)
Converts a list into tuple.

10. Built-in Dictionary Functions & Methods

Python includes the following dictionary functions −

1	cmp(dict1, dict2)
Compares elements of both dict.

2	len(dict)
Gives the total length of the dictionary. This would be equal to the number of items in the dictionary.

3	str(dict)
Produces a printable string representation of a dictionary

4	type(variable)
Returns the type of the passed variable. If passed variable is dictionary, then it would return a dictionary type.

Python includes following dictionary methods −

Sr.No.	Methods with Description
1	dict.clear()
Removes all elements of dictionary dict

2	dict.copy()
Returns a shallow copy of dictionary dict

3	dict.fromkeys()
Create a new dictionary with keys from seq and values set to value.

4	dict.get(key, default=None)
For key key, returns value or default if key not in dictionary

5	dict.has_key(key)
Returns true if key in dictionary dict, false otherwise

6	dict.items()
Returns a list of dict's (key, value) tuple pairs

7	dict.keys()
Returns list of dictionary dict's keys

8	dict.setdefault(key, default=None)
Similar to get(), but will set dict[key]=default if key is not already in dict

9	dict.update(dict2)
Adds dictionary dict2's key-values pairs to dict

10	dict.values()
Returns list of dictionary dict's values


#####################################################################################################
#
#						https://www.python-course.eu/python3_pytest.php
#
#####################################################################################################

1. A variable is a way of referring
to a memory location used by a computer program. In many
programming languages a variable is a symbolic name for
this physical location. This memory location contains values,
like numbers, text or more complicated types. We can use this
variable to tell the computer to save some data in this location
or to retrieve some data from this location.

2. i = 42
The equal "=" sign in the assignment shouldn't be seen as "is equal to". It should be "read" or
interpreted as "is set to", meaning in our example "the variable i is set to 42".

3. Python variables are references to objects, but
the actual data is contained in the objects:

4. I am a python variable.My name is x and I can point to an arbitrary object.
In this case to an int object.
x = 42

5. As variables are pointing to objects and objects can be of arbitrary data type, variables cannot
have types associated with them.This is a huge difference to C, C++ or Java, where a variable
is associated with a fixed data type. This association can't be changed as long as the program is
running.
Therefore it is possible to write code like the following in Python:
>>> x = 42
>>> print(x)

6. We want to demonstrate something else now. Let's look at the following code:
>>> x = 42
>>> y = x
We created an integer object 42 and assigned it to the variable x. After this we assigned x to the
variable y. This means that both variables reference the same object.

x ---> 42 (an obect)   <---- y

7. y = 78
Python will create a new integer object with the content 78 and then the variable y will
reference this newly created object

8. How can we see or prove that x and y really reference the same object
The identity function id() can be used for this purpose. Every instance (object or variable) has
an identity, i.e., an integer which is unique within the script or program, i.e., other objects have
different identities.

9. 
>>> x = 42
>>> id(x)
10107136
>>> y = x
>>> id(x), id(y)
(10107136, 10107136)
>>> y = 78
>>> id(x), id(y)
(10107136, 10108288)
>>>

10. PYTHON KEYWORDS
No identifier can have the same name as one of the Python keywords, although they are
obeying the above naming conventions:

11. and, as, assert, break, class, continue, def, del,
elif, else,
except, False, finally, for, from, global, if, import,
in, is,
lambda, None, nonlocal, not, or, pass, raise, return,
True, try,
while, with, yield
There is no need to learn them by heart. You can get the list of Python keywords in the
interactive shell by using help. You type help() in the interactive, but please don't forget the
parenthesis:
>>> help()

12. The Style Guide for Python Code
recommends underscore notation for variable names as well as function names.

13. "All identifiers in the Python standard library MUST use ASCII-only identifiers, and SHOULD
use English words wherever feasible (in many cases, abbreviations and technical terms are
used which aren't English). In addition, string literals and comments must also be in ASCII.
The only exceptions are (a) test cases testing the non-ASCII features, and (b) names of authors.
Authors whose names are not based on the latin alphabet MUST provide a latin transliteration
of their names

14. In other words, "//" always truncates towards negative infinity.

>>> 9 // 3
3
>>> 10 // 3
3
>>> 11 // 3
3
>>> 12 // 3
4
>>> 10.0 // 3
3.0
>>> -7 // 3
-3
>>> -7.0 // 3
-3.0
>>>

15. In other words, the meaning of a character or a written or printed text doesn't depend
on the font or writing style used. On a computer the capital A is encoded in binary form. If we
use ASCII it is encoded - like all the other characters - as the byte 65.

16. Characters consist of graphical shapes, so-called graphemes, consisting of lines, curves and
crossings in certain angles or positions.

17. UNICODE ENCODINGS
UTF-32,  UTF-16, UTF-8.

18. All strings in Python 3 are sequences of "pure" Unicode characters, no specific
encoding like UTF-8.

19. There are different ways to define strings in Python:
>>> s = 'I am a string enclosed in single quotes.'
>>> s2 = "I am another string, but I am enclosed in
double quotes"
Both s and s2 of the previous example are variables referencing string objects. We can see that
string literals can either be enclosed in matching single (') or in double quotes ("). Single quotes
will have to be escaped with a backslash (\), if the string is defined with single quotes:
>>> s3 = 'It doesn\'t matter!'
This is not necessary, if the string is represented by double quotes:
>>> s3 = "It doesn't matter!"
Analogously, we will have to escape a double quote inside a double quoted string:
>>> txt = "He said: \"It doesn't matter, if you enclose
a string in single or double quotes!\""
>>> print(txt)
He said: "It doesn't matter, if you enclose a string in
single or double quotes!"
>>>

20. SOME OPERATORS AND FUNCTIONS FOR STRINGS
Concatenation
Strings can be glued together (concatenated) with the + operator:
"Hello" + "World" will result in "HelloWorld"
Repetition
String can be repeated or repeatedly concatenated with the asterisk operator "*":
"*-*" * 3 will result in "*-**-**-*"
Indexing
"Python"[0] will result in "P"
Slicing
Substrings can be created with the slice or slicing notation, i.e., two indices in square
brackets separated by a colon:
"Python"[2:4] will result in "th"
Size
len("Python") will result in 6

21. IMMUTABLE STRINGS

Python strings cannot be changed. Trying to change
an indexed position will raise an error:
>>> s = "Some things are immutable!"
>>> s[-1] = "."
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
TypeError: 'str' object does not support item
assignment
>>>
Beginners in Python are often confused, when they see the following codelines:
>>> txt = "He lives in Berlin!"
>>> txt = "He lives in Hamburg!"
The variable "txt" is a reference to a string object. We define a completely new string object in
the second assignment. So, you shouldn't confuse the variable name with the referenced object!

22. >>> a = "Linux"
>>> b = "Linux"
>>> a is b
True

23. >>> a = "Baden-Württemberg"
>>> b = "Baden-Württemberg"
>>> a is b
False
>>> a == b
True
You are right, it has nothing to do with geographical places. The special character, i.e., the
hyphen, is to "blame".
>>> a = "Baden!"
>>> b = "Baden!"
>>> a is b
False
>>> a = "Baden1"
>>> b = "Baden1"
>>> a is b
True

24. String literals may optionally be prefixed with
a letter 'r' or 'R'; these strings are called raw strings.

25. Every string or text in Python 3 is Unicode, but encoded Unicode is represented as
binary data.

26. While a string object holds a sequence of characters (in Unicode), a bytes object holds a
sequence of bytes, out of the range 0 .. 255, representing the ASCII values.
Defining bytes objects and casting them into strings:
>>> x = b"Hallo"
>>> t = str(x)
>>> u = t.encode("UTF-8")

############################################################################################################
27. LIST

(a) s.append(x)
This method appends an element to the end of the list "s".
>>> lst = [3, 5, 7]
>>> lst.append(42)
>>> lst
[3, 5, 7, 42]
>>>

(b) It's import to understand that append returns "None". This means that it usually
doesn't make sense to reassign the return value:
>>> lst = [3, 5, 7]
>>> lst = lst.append(42)
>>> print(lst)
None
>>>

(c) s.pop(i)
'pop' returns the ith element of a list s. The element will be removed from the list
as well.
>>> cities = ["Hamburg", "Linz", "Salzburg",
"Vienna"]

>>> cities.pop(0)
'Hamburg'
>>> cities
['Linz', 'Salzburg', 'Vienna']
>>> cities.pop(1)
'Salzburg'
>>> cities
['Linz', 'Vienna']
>>>
The method 'pop' raises an IndexError exception if the list is empty or the index is
out of range.

(d) s.pop() is equivalent to s.pop(-1).

>>> cities = ["Amsterdam", "The Hague",
"Strasbourg"]
>>> cities.pop()
'Strasbourg'
>>> cities
['Amsterdam', 'The Hague']
>>>

(e)
Python provides the method 'extend'. It extends a list by appending all
the elements of an iterable like a list, a tuple or a string to a list:
>>> lst = [42,98,77]
>>> lst2 = [8,69]
>>> lst.extend(lst2)
>>> lst
[42, 98, 77, 8, 69]
>>>

(f)

>>> lst = ["a", "b", "c"]
>>> programming_language = "Python"
>>> lst.extend(programming_language)
>>> print(lst)
['a', 'b', 'c', 'P', 'y', 't', 'h', 'o', 'n']

(g)

>>> lst = ["Java", "C", "PHP"]
>>> t = ("C#", "Jython", "Python", "IronPython")
>>> lst.extend(t)
>>> lst
['Java', 'C', 'PHP', 'C#', 'Jython', 'Python',
'IronPython']
>>>

(h)
EXTENDING AND APPENDING LISTS WITH THE '+'-OPERATOR

There is an alternative to 'append' and 'extend'. '+' can be used to combine lists.
>>> level = ["beginner", "intermediate",
"advanced"]
>>> other_words = ["novice", "expert"]
>>> level + other_words
['beginner', 'intermediate', 'advanced', 'novice',
'expert']
>>>

(i)
Be careful. Never ever do the following:
>>> L = [3, 4]
>>> L = L + [42]
>>> L
[3, 4, 42]
>>>
Even though we get the same result, it is not an alternative to 'append' and 'extend':
>>> L = [3, 4]
>>> L.append(42)
>>> L
[3, 4, 42]
>>>
>>>
>>> L = [3, 4]
>>> L.extend([42])
>>> L
[3, 4, 42]
>>>

(j) We will compare in the following example the different approaches and calculate their
run times. To understand the following program, you need to know that time.time()
returns a float number, the time in seconds since the so-called ,,The Epoch''1.
time.time() - start_time calculates the time in seconds consumed for the for loops:
import time
n= 100000
start_time = time.time()
l = []
for i in range(n):
l = l + [i * 2]
print(time.time() - start_time)
start_time = time.time()
l = []
for i in range(n):
l += [i * 2]
print(time.time() - start_time)
start_time = time.time()
l = []
for i in range(n):
l.append(i * 2)
print(time.time() - start_time)
This program returns shocking results:
10/31/2019 Python Tutorial: A Tutorial
https://www.python-course.eu/python3_list_manipulation.php 7/10
26.3175041676
0.0305399894714
0.0207479000092
We can see that the "+" operator is about 1268 slower than the append method. The
explanation is easy: If we use the append method, we will simply append a further
element to the list in each loop pass. Now we come to the first loop, in which we use l
= l + [i * 2]. The list will be copied in every loop pass. The new element will be
added to the copy of the list and result will be reassigned to the variable l. After this the
old list will have to be removed by Python, because it is not referenced anymore. We
can also see that the version with the augmented assignment ("+="), the loop in the
middle, is only slightly slower than the version using "append".

(k) REMOVING AN ELEMENT WITH REMOVE
It is possible to remove with the method "remove" a certain value from a list without
knowing the position.
s.remove(x)

(l) This call will remove the first occurrence of x from the list s. If x is not contained in the
list, a ValueError will be raised.

(m) FIND THE POSITION OF AN ELEMENT IN A LIST
>>> colours = ["red", "green", "blue", "green",
"yellow"]
>>> colours.index("green")
1
>>> colours.index("green", 2)
3
>>> colours.index("green", 3,4)
3
>>> colours.index("black")
Traceback (most recent call last):
File "", line 1, in
ValueError: 'black' is not in list
>>>

(n) INSERT
An object "object" will be included in the list "s". "object" will be placed before the
element s[index]. s[index] will be "object" and all the other elements will be moved one
to the right.
>>> lst = ["German is spoken", "in Germany,",
"Austria", "Switzerland"]
>>> lst.insert(3, "and")
>>> lst
['German is spoken', 'in Germany,', 'Austria',
'and', 'Switzerland']
>>>

28. Sets
They are used for example to get rid of doublets -
multiple occurrences of elements - in a list, i.e.
to make a list unique.

29. To cut out all the words of the novel "Ulysses" we can use the function findall from the
module "re":
import re
# we don't care about case sensitivity and
therefore use lower:
ulysses_txt =
open("books/james_joyce_ulysses.txt").read().lower()
words = re.findall(r"\b[\w-]+\b", ulysses_txt)
print("The novel ulysses contains " +
str(len(words)))
The novel ulysses contains 272452

30. This number is the sum of all the words and many words occur multiple time:
for word in ["the", "while", "good", "bad",
"ireland", "irish"]:
print("The word '" + word + "' occurs " + \
str(words.count(word)) + " times in the
novel!" )
The word 'the' occurs 15112 times in the novel!
The word 'while' occurs 123 times in the novel!
The word 'good' occurs 321 times in the novel!
The word 'bad' occurs 90 times in the novel!
The word 'ireland' occurs 90 times in the novel!
The word 'irish' occurs 117 times in the novel!

31. what is the difference between an iterable and an iterator ?

(a) You can iterate with a for loop over iterators and
iterables. Every iterator is also an iterable, but not every iterable is an iterator. E.g. a list
is iterable but a list is not an iterator! An iterator can be created from an iterable by
using the function 'iter'. To make this possible the class of an object needs either a
method '__iter__', which returns an iterator, or a '__getitem__' method with sequential
indexes starting with 0.

(b) Iterators are objects with a '__next__' method, which will be used when the function
'next' is called.

(c) So what is going on behind the scenes, when a for loop is executed? The for statement
calls iter() on the object ( which should be a so-called container object), which it is
supposed to loop over. If this call is successful, the iter call will return return an iterator
object that defines the method __next__() which accesses elements of the object one at
a time. The __next__() method will raise a StopIteration exception, if there are no
further elements available. The for loop whill terminate as soon as it catches a
StopIteration exception. You can call the __next__() method using the next() built-in
function. This is how it works:

cities = ["Berlin", "Vienna", "Zurich"]
iterator_obj = iter(cities)
print(iterator_obj)
print(next(iterator_obj))
print(next(iterator_obj))
print(next(iterator_obj))
<list_iterator object at 0x7f08a055e0b8>
Berlin
Vienna
Zurich

(d) So if you want to add an iterator behavior to
your class, you have to add the __iter__ and the __next__ method to your class. The
__iter__ method returns an iterator object. If the class contains a __next__, it is enough
for the __iter__ method to return self, i.e. a reference to itself:
class Reverse:
"""
Creates Iterators for looping over a sequence
backwards.
"""
def __init__(self, data):
self.data = data
self.index = len(data)
def __iter__(self):
return self
def __next__(self):
if self.index == 0:
raise StopIteration
self.index = self.index - 1
return self.data[self.index]
lst = [34, 978, 42]
lst_backwards = Reverse(lst)
for el in lst_backwards:
print(el)
42
978
34

32. CLASS ATTRIBUTES

a. Instance attributes are owned by the specific instances of a class.
b. Class attributes are attributes which are owned by the class itself.
   They will be shared by all the instances of the
class. Therefore they have the same value for every instance. We define class attributes
outside of all the methods, usually they are placed at the top, right below the class
header.

33. Besides this, we see that we can
access a class attribute via an instance or via the class name:

>>> class A:
	a = 5

	
>>> x = A()
>>> y = A()
>>> x.a
5
>>> y.a
5
>>> A.a
5
>>> x.a = 100
>>> x.a
100
>>> y.a
5
>>> A.a
5
>>> A.a = 999
>>> x.a
100
>>> y.a
999
>>> A.a
999
>>> x.__dict__
{'a': 100}
>>> y.__dict__
{}
>>> A.__dict__
mappingproxy({'__module__': '__main__', 'a': 999, '__dict__': <attribute '__dict__' of 'A' objects>, '__weakref__': <attribute '__weakref__' of 'A' objects>, '__doc__': None})
>>> 

34. 
how you can count instance with class
attributes. All we have to do is
to create a class attribute, which we call "counter" in our example
to increment this attribute by 1 every time a new instance will be create
to decrement the attribute by 1 every time an instance will be destroyed
class C:
counter = 0
def __init__(self):
type(self).counter += 1
def __del__(self):
type(self).counter -= 1
if __name__ == "__main__":
x = C()
print("Number of instances: : " +
str(C.counter))
y = C()
print("Number of instances: : " +
str(C.counter))
del x
print("Number of instances: : " +
str(C.counter))
del y

print("Number of instances: : " +
str(C.counter))

Principially, we could have written C.counter instead of type(self).counter, because
type(self) will be evaluated to "C" anyway. But we will see later, that type(self) makes
sense, if we use such a class as a superclass.

35. STATIC METHODS

(a) Of course, we can
make public attributes private as well. We can do this by adding the double underscore
again. If we do so, we need a possibility to access and change these private class
attributes.

class Robot:
counter = 0
def __init__(self):
type(self).__counter += 1
@staticmethod
def RobotInstances():
return Robot.__counter
if __name__ == "__main__":
print(Robot.RobotInstances())
x = Robot()
print(x.RobotInstances())
y = Robot()
print(x.RobotInstances())
print(Robot.RobotInstances())
We will get the following output:
0
1
2
2

36. CLASS METHODS

(a) Like static methods class
methods are not bound to instances, but unlike static methods class methods are bound
to a class.

(b) class Robot:
__counter = 0
def __init__(self):
type(self).__counter += 1
@classmethod
def RobotInstances(cls):
return cls, Robot.__counter
if __name__ == "__main__":
print(Robot.RobotInstances())
x = Robot()
print(x.RobotInstances())
y = Robot()
print(x.RobotInstances())
print(Robot.RobotInstances())
The output looks like this:
$ python3 static_methods4.py
<class '__main__.Robot'>, 0)
<class '__main__.Robot'>, 1)
<class '__main__.Robot'>, 2)
<class '__main__.Robot'>, 2)
The use cases of class methods:
the are used in the definition of the so-called factory methods, which we will not
cover here.
They are often used, where we have static methods, which have to call other static
methods. To do this, we would have to hard code the class name, if we had to use
static methods. This is a problem, if we are in a use case, where we have inherited
classes.

(c)
class fraction(object):
def __init__(self, n, d):
self.numerator, self.denominator =
fraction.reduce(n, d)
@staticmethod
def gcd(a,b):
while b != 0:
a, b = b, a%b
return a
@classmethod
def reduce(cls, n1, n2):
g = cls.gcd(n1, n2)
return (n1 // g, n2 // g)
def __str__(self):
return
str(self.numerator)+'/'+str(self.denominator)

Using this class:
>>> from fraction1 import fraction
>>> x = fraction(8,24)
>>> print(x)
1/3
>>>

37. TRUE OR FALSE

The following objects are evaluated by Python as False:

numerical zero values (0, 0.0, 0.0+0.0j),
the Boolean value False,
empty strings,
empty lists and empty tuples,
empty dictionaries.
plus the special value None.
All other values are considered to be True.

38. lst = [3,4]
list.__dict__["append"](lst, 42)
lst
The previous Python code returned the following output:
[3, 4, 42]

39. items in dictionaries are accessed via keys and not via their position.

40. What happens, if we try to access a key, i.e. a city, which is not contained in the
dictionary? We raise a KeyError:

41. de_fr = {"rot" : "rouge", "grün" : "vert", "blau"
: "bleu", "gelb":"jaune"}
print("The French word for red is: " +
de_fr[en_de["red"]])
The output of the previous script:
{'blue': 'blau', 'green': 'grün', 'yellow':
'gelb', 'red': 'rot'}
rot
The French word for red is: rouge

42. We can use arbitrary types as values in a dictionary, but there is a restriction for the
keys. Only immutable data types can be used as keys, i.e. no lists or dictionaries can be
used:
If you use a mutable data type as a key, you get an error message:
>>> dic = { [1,2,3]:"abc"}
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
TypeError: list objects are unhashable

Tuple as keys are okay, as you can see in the following example:
>>> dic = { (1,2,3):"abc", 3.1415:"abc"}
>>> dic
{3.1415: 'abc', (1, 2, 3): 'abc'}

43. OPERATORS ON DICTIONARIES

Operator Explanation
len(d) returns the number of stored entries, i.e. the number of (key,value) pairs.
del d[k] deletes the key k together with his value
k in d True, if a key k exists in the dictionary d
k not in d True, if a key k doesn't exist in the dictionary d

44. If D is a dictionary, then D.pop(k) removes the key k with its value from the dictionary
D and returns the corresponding value as the return value, i.e. D[k].
If the key is not found a KeyError is raised:
>>> en_de = {"Austria":"Vienna",
"Switzerland":"Bern", "Germany":"Berlin",
"Netherlands":"Amsterdam"}
>>> capitals = {"Austria":"Vienna",
"Germany":"Berlin", "Netherlands":"Amsterdam"}
>>> capital = capitals.pop("Austria")
>>> print(capital)
Vienna
>>> print(capitals)
{'Netherlands': 'Amsterdam', 'Germany': 'Berlin'}
>>> capital = capitals.pop("Switzerland")
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
KeyError: 'Switzerland'
>>>
If we try to find out the capital of Switzerland in the previous example, we raise a
KeyError. To prevent these errors, there is an elegant way. The method pop() has an
optional second parameter, which can be used as a default value:
>>> capital = capitals.pop("Switzerland", "Bern")
>>> print(capital)
Bern
>>> capital = capitals.pop("France", "Paris")
>>> print(capital)
Paris
>>> capital = capitals.pop("Germany", "München")
>>> print(capital)
Berlin

>>> sample = {'a':1,'b':2,'c':3}
>>> sample
{'a': 1, 'b': 2, 'c': 3}
>>> output =sample.pop('a')
>>> output
1
>>> sample
{'b': 2, 'c': 3}
>>> sample.pop('b',2)
2
>>> sample
{'c': 3}
>>> 

45. >>> sample = {'a':1,'b':2,'c':3,'d':4}
>>> sample
{'a': 1, 'b': 2, 'c': 3, 'd': 4}
>>> sample.popitem()
('d', 4)
>>> sample
{'a': 1, 'b': 2, 'c': 3}
>>> sample.popitem()
('c', 3)
>>> sample
{'a': 1, 'b': 2}
>>> sample.popitem()
('b', 2)
>>> sample
{'a': 1}
>>> sample.popitem()
('a', 1)
>>> sample
{}
>>> sample.popitem()
Traceback (most recent call last):
  File "<pyshell#10>", line 1, in <module>
    sample.popitem()
KeyError: 'popitem(): dictionary is empty'
>>> 

46. get() method

>>> proj_language = {"proj1":"Python",
"proj2":"Perl", "proj3":"Java"}
>>> proj_language["proj1"]
'Python'
>>> proj_language["proj4"]
Traceback (most recent call last):
File "<stdin>", line 1, in
KeyError: 'proj4'
>>> proj_language.get("proj2")
'Perl'
>>> proj_language.get("proj4")
>>> print(proj_language.get("proj4"))
None
>>> # setting a default value:
>>> proj_language.get("proj4", "Python")
'Python'
>>>

47. A dictionary can be copied with the method copy():
>>> w = words.copy()
>>> words["cat"]="chat"
>>> print(w)
{'house': 'Haus', 'cat': 'Katze'}
>>> print(words)
{'house': 'Haus', 'cat': 'chat'}
This copy is a shallow and not a deep copy.

48. The content of a dictionary can be cleared with the method clear(). The dictionary is not
deleted, but set to an empty dictionary:
>>> w.clear()
>>> print(w)
{}

49. >>> knowledge = {"Frank": {"Perl"}, "Monica":
{"C","C++"}}
>>> knowledge2 = {"Guido":{"Python"}, "Frank":
{"Perl", "Python"}}
>>> knowledge.update(knowledge2)
>>> knowledge
{'Frank': {'Python', 'Perl'}, 'Guido': {'Python'},
'Monica': {'C', 'C++'}}

50. No method is needed to iterate over the keys of a dictionary:
>>> d = {"a":123, "b":34, "c":304, "d":99}
>>> for key in d:
... print(key)
...
b
c
a
d
>>>
But it's possible to use the method keys(), but we will get the same result:
>>> for key in d.keys():
... print(key)
...
b
c
a
d
>>>
The method values() is a convenient way for iterating directly over the values:
>>> for value in d.values():
... print(value)
...
34
304
123
99
>>>
The above loop is logically equivalent to the following one:

for key in d:
print(d[key])
We said logically, because the second way is less efficient!

51. >>> w = {"house":"Haus", "cat":"", "red":"rot"}
>>> items_view = w.items()
>>> items = list(items_view)
>>> items
[('house', 'Haus'), ('cat', ''), ('red', 'rot')]
>>>
>>> keys_view = w.keys()
>>> keys = list(keys_view)
>>> keys
['house', 'cat', 'red']
>>>
>>> values_view = w.values()
>>> values = list(values_view)
>>> values
['Haus', '', 'rot']
>>> values_view
dict_values(['Haus', '', 'rot'])
>>> items_view
dict_items([('house', 'Haus'), ('cat', ''),
('red', 'rot')])
>>> keys_view
dict_keys(['house', 'cat', 'red'])
>>>

52. TURN LISTS INTO DICTIONARIES

Now we will turn our attention to the art of cooking, but don't be afraid, this remains a
python course and not a cooking course. We want to show you, how to turn lists into
dictionaries, if these lists satisfy certain conditions.
We have two lists, one containing the dishes and the other one the corresponding
countries:

>>> dishes = ["pizza", "sauerkraut", "paella",
"hamburger"]
>>> countries = ["Italy", "Germany", "Spain",
"USA"]
Now we will create a dictionary, which assigns a dish, a country-specific dish, to a
country; please forgive us for resorting to the common prejudices. For this purpose we
need the function zip(). The name zip was well chosen, because the two lists get
combined like a zipper. The result is a list iterator. This means that we have to wrap a
list() casting function around the zip call to get a list so that we can see what is going
on:
>>> country_specialities_iterator = zip(countries,
dishes)
>>> country_specialities_iterator
<zip object at 0x7fa5f7cad408>
>>> country_specialities =
list(country_specialities_iterator)
>>> print(country_specialities)
[('Italy', 'pizza'), ('Germany', 'sauerkraut'),
('Spain', 'paella'), ('USA', 'hamburger')]
>>>
Now our country-specific dishes are in a list form, - i.e. a list of two-tuples, where the
first components are seen as keys and the second components as values - which can be
automatically turned into a dictionary by casting it with dict().
>>> country_specialities_dict =
dict(country_specialities)
>>> print(country_specialities_dict)
{'USA': 'hamburger', 'Germany': 'sauerkraut',
'Spain': 'paella', 'Italy': 'pizza'}
>>>
Yet, this is very inefficient, because we created a list of 2-tuples to turn this list into a
dict. This can be done directly by applying dict to zip:
10/31/2019 Python Tutorial: Dictionaries
https://www.python-course.eu/python3_dictionaries.php 20/23
>>> dishes = ["pizza", "sauerkraut", "paella",
"hamburger"]
>>> countries = ["Italy", "Germany", "Spain",
"USA"]
>>> dict(zip(countries, dishes))
{'USA': 'hamburger', 'Germany': 'sauerkraut',
'Spain': 'paella', 'Italy': 'pizza'}
>>>
There is still one question concerning the function zip(). What happens, if one of the
two argument lists contains more elements than the other one?
It's easy to answer: The superfluous elements, which cannot be paired, will be ignored:
>>> dishes = ["pizza", "sauerkraut", "paella",
"hamburger"]
>>> countries = ["Italy", "Germany", "Spain",
"USA"," Switzerland"]
>>> country_specialities = list(zip(countries,
dishes))
>>> country_specialities_dict =
dict(country_specialities)
>>> print(country_specialities_dict)
{'Germany': 'sauerkraut', 'Italy': 'pizza', 'USA':
'hamburger', 'Spain': 'paella'}
>>>
So in this course, we will not answer the burning question, what the national dish of
Switzerland is.
EVERYTHING IN ONE STEP
10/31/2019 Python Tutorial: Dictionaries
https://www.python-course.eu/python3_dictionaries.php 21/23
Normally, we recommend not to implement too many steps in one programming
expression, though it looks more impressive and the code is more compact. Using
"talking" variable names in intermediate steps can enhance legibility. Though it might
be alluring to create our previous dictionary just in one go:
>>> country_specialities_dict =
dict(list(zip(["pizza", "sauerkraut", "paella",
"hamburger"], ["Italy", "Germany", "Spain",
"USA"," Switzerland"])))
>>> print(country_specialities_dict)
{'paella': 'Spain', 'hamburger': 'USA',
'sauerkraut': 'Germany', 'pizza': 'Italy'}
>>>
On the other hand, the code in the previous script is gilding the lily:
dishes = ["pizza", "sauerkraut", "paella",
"hamburger"]
countries = ["Italy", "Germany", "Spain", "USA"]
country_specialities_zip = zip(dishes,countries)
print(list(country_specialities_zip))
country_specialities_list =
list(country_specialities_zip)
country_specialities_dict =
dict(country_specialities_list)
print(country_specialities_dict)
We get the same result, as if we would have called it in one go.

53. You have to keep in mind that iterators exhaust
themselves, if they are used. You can see this in the following interactive session:
>>> l1 = ["a","b","c"]
>>> l2 = [1,2,3]
>>> c = zip(l1, l2)
>>> for i in c:
... print(i)
...
('a', 1)
('b', 2)
('c', 3)
>>> for i in c:
... print(i)
...
This effect can be seen by calling the list casting operator as well:
>>> l1 = ["a","b","c"]
>>> l2 = [1,2,3]
>>> c = zip(l1,l2)
>>> z1 = list(c)
>>> z2 = list(c)
>>> print(z1)
[('a', 1), ('b', 2), ('c', 3)]
>>> print(z2)
[]
As an exercise, you may muse about the following script.
dishes = ["pizza", "sauerkraut", "paella",
"hamburger"]
countries = ["Italy", "Germany", "Spain", "USA"]
country_specialities_zip = zip(dishes,countries)
print(list(country_specialities_zip))
country_specialities_list =
list(country_specialities_zip)
country_specialities_dict =
dict(country_specialities_list)
print(country_specialities_dict)
If you start this script, you will see that the dictionary you want to create will be empty:
$ python3 tricky_code.py
[('pizza', 'Italy'), ('sauerkraut', 'Germany'),
('paella', 'Spain'), ('hamburger', 'USA')]
{}
$

############################################################################################################
54. that applying "type" to an object returns the class of
which the object is an instance of:

x = [4, 5, 9]
y = "Hello"
print(type(x), type(y))
The code above returned the following:
<class 'list'> <class 'str'>

55. If you apply type on the name of a class itself, you get the class "type" returned.
print(type(list), type(str))
The above Python code returned the following:
<class 'type'> <class 'type'>

56. This is similar to applying type on type(x) and type(y):
x = [4, 5, 9]
y = "Hello"
print(type(x), type(y))
print(type(type(x)), type(type(y)))
This gets us the following result:
<class 'list'> <class 'str'>
<class 'type'> <class 'type'>

57. A user-defined class (or the class "object") is an instance of the class "type". So, we can
see, that classes are created from type. In Python3 there is no difference between
"classes" and "types". They are in most cases used as synonyms.

58. The fact that classes are instances of a class "type" allows us to program metaclasses.
We can create classes, which inherit from the class "type". So, a metaclass is a subclass
of the class "type".

59. Instead of only one argument, type can be called with three parameters:
type(classname, superclasses, attributes_dict)
If type is called with three arguments, it will return a new type object. This provides us
with a dynamic form of the class statement.
(a) "classname" is a string defining the class name and becomes the name attribute;
(b) "superclasses" is a list or tuple with the superclasses of our class. This list or tuple
will become the bases attribute;
(c) the attributes_dict is a dictionary, functioning as the namespace of our class. It
contains the definitions for the class body and it becomes the dict attribute.

60. class A:
pass
x = A()
print(type(x))
After having executed the Python code above we received the following result:
<class '__main__.A'>
We can use "type" for the previous class defintion as well:
A = type("A", (), {})
x = A()
print(type(x))
The previous Python code returned the following result:
<class '__main__.A'>
Generally speaking, this means, that we can define a class A with
type(classname, superclasses, attributedict)
When we call "type", the call method of type is called. The call method runs two other
methods: new and init:
type.__new__(typeclass, classname, superclasses,
attributedict)
type.__init__(cls, classname, superclasses,
attributedict)

The new method creates and returns the new class object, and after this the init method
initializes the newly created object.

61. class Robot:
counter = 0
def __init__(self, name):
self.name = name
def sayHello(self):
return "Hi, I am " + self.name
def Rob_init(self, name):
self.name = name
Robot2 = type("Robot2",
(),
{"counter":0,
"__init__": Rob_init,
"sayHello": lambda self: "Hi, I am
" + self.name})
x = Robot2("Marvin")
print(x.name)
print(x.sayHello())
y = Robot("Marvin")
print(y.name)
print(y.sayHello())
print(x.__dict__)
print(y.__dict__)
The previous Python code returned the following result:
Marvin
Hi, I am Marvin
Marvin
Hi, I am Marvin
{'name': 'Marvin'}
{'name': 'Marvin'}

The class definitions for Robot and Robot2 are syntactically completely different, but
they implement logically the same class.

############################################################################################################
62. We have two different kinds of decorators in Python:
Function decorators
Class decorators

63. A decorator in Python is any callable
Python object that is used to modify a function or a class. A reference to a function
"func" or a class "C" is passed to a decorator and the decorator returns a modified
function or class. The modified functions or classes usually contain calls to the original
function "func" or class "C".

64. First you have to know or remember that function names are references to
functions and that we can assign multiple names to the same function:
>>> def succ(x):
... return x + 1
...
>>> successor = succ
>>> successor(10)
11
>>> succ(10)
11

65. This means that we have two names, i.e. "succ" and "successor" for the same function.
The next important fact is that we can delete either "succ" or "successor" without
deleting the function itself.
>>> del succ
>>> successor(10)
11

66. 
def our_decorator(func):
def function_wrapper(x):
print("Before calling " + func.__name__)
func(x)
print("After calling " + func.__name__)
return function_wrapper
@our_decorator
def foo(x):
print("Hi, foo has been called with " +
str(x))
foo("Hi")
We can decorate every other function which takes one parameter with our decorator
'our_decorator'. We demonstrate this in the following. We have slightly changed our
function wrapper, so that we can see the result of the function calls:
def our_decorator(func):
def function_wrapper(x):
print("Before calling " + func.__name__)
res = func(x)
print(res)
print("After calling " + func.__name__)
return function_wrapper
@our_decorator
def succ(n):
return n + 1
succ(10)
The output of the previous program:
Before calling succ
11
After calling succ

67. CHECKING ARGUMENTS WITH A DECORATOR

The following program uses a decorator function to ensure that the argument passed to
the function factorial is a positive integer:
def argument_test_natural_number(f):
def helper(x):
if type(x) == int and x > 0:
return f(x)
else:
raise Exception("Argument is not an
integer")
return helper
@argument_test_natural_number
def factorial(n):
if n == 1:
return 1
else:
return n * factorial(n-1)
for i in range(1,10):
print(i, factorial(i))
print(factorial(-1))

68. COUNTING FUNCTION CALLS WITH DECORATORS

def call_counter(func):
def helper(x):
helper.calls += 1
return func(x)
helper.calls = 0
return helper
@call_counter
def succ(x):
return x + 1
print(succ.calls)
for i in range(10):
succ(i)
print(succ.calls)

69. 
def call_counter(func):
def helper(*args, **kwargs):
helper.calls += 1
return func(*args, **kwargs)
helper.calls = 0
return helper
@call_counter
def succ(x):
return x + 1
@call_counter
def mul1(x, y=1):
return x*y + 1
print(succ.calls)
for i in range(10):
succ(i)
mul1(3, 4)
mul1(4)
mul1(y=3, x=2)
print(succ.calls)
print(mul1.calls)

The output looks like this:
0
10
3

70. 
def greeting(expr):
def greeting_decorator(func):
def function_wrapper(x):
print(expr + ", " + func.__name__ + "
returns:")
func(x)
return function_wrapper
return greeting_decorator
@greeting("καλημερα")
def foo(x):
print(42)
foo("Hi")
The output:
καλημερα, foo returns:
42
If we don't want or cannot use the "at" decorator syntax, we can do it with function
calls:
def greeting(expr):
def greeting_decorator(func):
def function_wrapper(x):
print(expr + ", " + func.__name__ + " returns:")
func(x)
return function_wrapper
return greeting_decorator
def foo(x):
print(42)
greeting2 = greeting("καλημερα")
foo = greeting2(foo)
foo("Hi")
The result is the same as before:
καλημερα, foo returns:
42
Of course, we don't need the additional definition of "greeting2". We can directly apply
the result of the call "greeting("καλημερα")" on "foo":
foo = greeting("καλημερα")(foo)

71. USING WRAPS FROM FUNCTOOLS

The way we have defined decorators so far hasn't taken into account that the attributes
__name__ (name of the function),
__doc__ (the docstring) and
__module__ (The module in which the function is defined)
of the original functions will be lost after the decoration.
The following decorator will be saved in a file greeting_decorator.py:

def greeting(func):
def function_wrapper(x):
""" function_wrapper of greeting """
print("Hi, " + func.__name__ + "
returns:")
return func(x)
return function_wrapper
We call it in the following program:
from greeting_decorator import greeting
@greeting
def f(x):
""" just some silly function """
return x + 4
f(10)
print("function name: " + f.__name__)
print("docstring: " + f.__doc__)
print("module name: " + f.__module__)
We get the following "unwanted" results:
Hi, f returns:
function name: function_wrapper
docstring: function_wrapper of greeting
module name: greeting_decorator

72. 
We can import the decorator "wraps" from functools instead and decorate our function
in the decorator with it:
from functools import wraps
def greeting(func):
@wraps(func)
def function_wrapper(x):
""" function_wrapper of greeting """
print("Hi, " + func.__name__ + "
returns:")
return func(x)
return function_wrapper

73. USING A CLASS AS A DECORATOR

class decorator2:
def __init__(self, f):
self.f = f
def __call__(self):
print("Decorating", self.f.__name__)
self.f()
@decorator2
def foo():
print("inside foo()")
foo()

Both versions return the same output:
Decorating foo
inside foo()

############################################################################################################
LIST COMPREHENSION

74. List comprehension is a complete substitute for the lambda function as well as the
functions map(), filter() and reduce().List comprehension is an elegant way to define and create list in Python.

75. convert Celsius values into Fahrenheit and vice versa.
>>> Celsius = [39.2, 36.5, 37.3, 37.8]
>>> Fahrenheit = [ ((float(9)/5)*x + 32) for x in
Celsius ]
>>> print(Fahrenheit)
[102.56, 97.700000000000003, 99.140000000000001,
100.03999999999999]
>>>

76.
The following list comprehension creates the Pythagorean triples:
>>> [(x,y,z) for x in range(1,30) for y in
range(x,30) for z in range(y,30) if x**2 + y**2 ==
z**2]
[(3, 4, 5), (5, 12, 13), (6, 8, 10), (7, 24, 25),
(8, 15, 17), (9, 12, 15), (10, 24, 26), (12, 16,
20),(15, 20, 25), (20, 21, 29)]

77.
>>> colours = [ "red", "green", "yellow", "blue" ]
>>> things = [ "house", "car", "tree" ]
>>> coloured_things = [ (x,y) for x in colours for
y in things ]
>>> print(coloured_things)
[('red', 'house'), ('red', 'car'), ('red',
'tree'), ('green', 'house'), ('green', 'car'),
('green', 'tree'), ('yellow', 'house'), ('yellow',
'car'), ('yellow', 'tree'), ('blue', 'house'),
('blue', 'car'), ('blue', 'tree')]
>>>

78. GENERATOR COMPREHENSION

a generator comprehension returns a generator instead of a list.
>>> x = (x **2 for x in range(20))
>>> print(x)
at 0xb7307aa4>
>>> x = list(x)
>>> print(x)
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121,
144, 169, 196, 225, 256, 289, 324, 361]

79. SET COMPREHENSION

>>> from math import sqrt
>>> n = 100
>>> sqrt_n = int(sqrt(n))
>>> no_primes = {j for i in range(2, sqrt_n+1) for
j in range(i*2, n, i)}
>>> no_primes
{4, 6, 8, 9, 10, 12, 14, 15, 16, 18, 20, 21, 22,
24, 25, 26, 27, 28, 30, 32, 33, 34, 35, 36, 38,
39, 40, 42, 44, 45, 46, 48, 49, 50, 51, 52, 54,
55, 56, 57, 58, 60, 62, 63, 64, 65, 66, 68, 69,
70, 72, 74, 75, 76, 77, 78, 80, 81, 82, 84, 85,
86, 87, 88, 90, 91, 92, 93, 94, 95, 96, 98, 99}
>>> primes = {i for i in range(2, n) if i not in
no_primes}
>>> print(primes)
{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,
43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}
>>>

80. RECURSIVE FUNCTION TO CALCULATE THE PRIMES

The following Python script uses a recursive function to calculate the prime numbers. It
incorporates the fact that it is enough to examine the multiples of the prime numbers up
to the square root of n:
from math import sqrt
def primes(n):
if n == 0:
return []
elif n == 1:
return []
else:
p = primes(int(sqrt(n)))
no_p = {j for i in p for j in range(i*2,
n+1, i)}
p = {x for x in range(2, n + 1) if x not
in no_p}
return p
for i in range(1,50):
print(i, primes(i))

############################################################################################################
R E G U L A R E X P R E S S I O N S

81. [a-e] a simplified writing for [abcde] or [0-5] denotes [012345]

82. Exercise:
What character class is described by [-a-z]?
Answer The character "-" and all the characters "a", "b", "c" all the way up to "z".

83. The only other special character inside square brackets (character class choice) is the
caret "^". If it is used directly after an opening sqare bracket, it negates the choice. [^0-
9] denotes the choice "any character but a digit". The position of the caret within the
square brackets is crucial. If it is not positioned as the first character following the
opening square bracket, it has no special meaning.
[^abc] means anything but an "a", "b" or "c"
[a^bc] means an "a", "b", "c" or a "^"

84. 
M1
---
import re
fh = open("simpsons_phone_book.txt")
for line in fh:
if re.search(r"J.*Neu",line):
print(line.rstrip())
fh.close()
The program above returns the following results:
Jack Neu 555-7666
Jeb Neu 555-5543
Jennifer Neu 555-3652

M2
---
Instead of downloading simpsons_phone_book.txt, we can use the file directly from the
website by using urlopen from the module urllib.request:
import re
from urllib.request import urlopen
with urlopen('https://www.pythoncourse.
eu/simpsons_phone_book.txt') as fh:
for line in fh:
# line is a byte string so we transform it
to utf-8:
line = line.decode('utf-8').rstrip()
if re.search(r"J.*Neu",line):
print(line)

85. PREDEFINED CHARACTER CLASSES
\d Matches any decimal digit; equivalent to the set [0-9].
\D The complement of \d. It matches any non-digit character; equivalent to the set
[^0-9].
\s Matches any whitespace character; equivalent to [ \t\n\r\f\v].
\S The complement of \s. It matches any non-whitespace character; equiv. to [^
\t\n\r\f\v].
\w
Matches any alphanumeric character; equivalent to [a-zA-Z0-9_]. With LOCALE,
it will match the set [a-zA-Z0-9_] plus characters defined as letters for the current
locale.
\W Matches the complement of \w.
\b Matches the empty string, but only at the start or end of a word.
\B Matches the empty string, but not at the start or end of a word.
\\ Matches a literal backslash.

86. >>> import re
>>> s1 = "Mayer is a very common Name"
>>> s2 = "He is called Meyer but he isn't German."
>>> print(re.search(r"^M[ae][iy]er", s1))
<_sre.SRE_Match object at 0x7fc59c5f26b0>
>>> print(re.search(r"^M[ae][iy]er", s2))
None
But what happens if we concatenate the two strings s1 and s2 in the following way:
s = s2 + "\n" + s1
Now the string doesn't start with a Maier of any kind, but the name is following a
newline character:
>>> s = s2 + "\n" + s1
>>> print(re.search(r"^M[ae][iy]er", s))
None
>>>

87.
>>> print(re.search(r"^M[ae][iy]er", s,
re.MULTILINE))
<_sre.SRE_Match object at 0x7fc59c5f26b0>
>>> print(re.search(r"^M[ae][iy]er", s, re.M))
<_sre.SRE_Match object at 0x7fc59c5f26b0>
>>> print(re.match(r"^M[ae][iy]er", s, re.M))
None
>>>
The previous example also shows that the multiline mode doesn't affect the match
method. match() never checks anything but the beginning of the string for a match.

88.
>>> print(re.search(r"Python\.$","I like
Python."))
<_sre.SRE_Match object at 0x7fc59c5f26b0>
>>> print(re.search(r"Python\.$","I like Python
and Perl."))
None
>>> print(re.search(r"Python\.$","I like
Python.\nSome prefer Java or Perl."))
None
>>> print(re.search(r"Python\.$","I like
Python.\nSome prefer Java or Perl.", re.M))
<_sre.SRE_Match object at 0x7fc59c5f26b0>
>>>

89.
If we try to figure out a fitting regular expression, we realize that we miss something. A
way to tell the computer "this "e" may or may not occur". A question mark is used as a
notation for this. A question mark declares that the preceding character or expression is
optional.
The final Mayer-Recognizer looks now like this:
r"M[ae][iy]e?r"
A subexpression is grouped by round brackets and a question mark following such a
group means that this group may or may not exist. With the following expression we
can match dates like "Feb 2011" or February 2011":
r"Feb(ruary)? 2011"

90. QUANTIFIERS

A quantifier after a token, which can be a single character or group in brackets,
specifies how often that preceding element is allowed to occur. The most common
quantifiers are
the question mark ?
the asterisk or star character *, which is derived from the Kleene star
and the plus sign +, derived from the Kleene cross

91.
Exercise:
Write a regular expression which matches strings which starts with a sequence of digits
- at least one digit - followed by a blank.
Solution:
r"^[0-9][0-9]* "

92.
A star following a character or a subexpression group means that this
expression or character may be repeated arbitrarily, even zero times.
r"[0-9]*"

93. 
Using + or * are too unspecific for our purpose and the following expression seems to
be too clumsy:
r"^[0-9][0-9][0-9][0-9] [A-Za-z]+"
Fortunately, there is an alternative available:
r"^[0-9]{4} [A-Za-z]*"

94. 
r"^[0-9]{4,5} [A-Z][a-z]{2,}"
The general syntax is {from, to}: this means that the expression has to appear at least
"from" times and not more than "to" times. {, to} is an abbreviated spelling for {0,to}
and {from,} is an abbreviation for "at least from times but no upper limit"

95. A match object contains the methods group(), span(), start() and end(), as can be seen in
the following application:

>>> import re
>>> mo = re.search("[0-9]+", "Customer number:
232454, Date: February 12, 2011")
>>> mo.group()
'232454'
>>> mo.span()
(17, 23)
>>> mo.start()
17

96.
>>> mo.end()
23
>>> mo.span()[0]
17
>>> mo.span()[1]
23
>>>
These methods are not difficult to understand. span() returns a tuple with the start and
end position, i.e. the string index where the regular expression started matching in the
string and ended matching. The methods start() and end() are in a way superfluous as
the information is contained in span(), i.e. span()[0] is equal to start() and span()[1] is
equal to end(). group(), if called without argument, returns the substring, which had
been matched by the complete regular expression. With the help of group() we are also
capable of accessing the matched substring by grouping parentheses, to get the matched
substring of the n-th group, we call group() with the argument n: group(n).
We can also call group with more than integer argument, e.g. group(n,m). group(n,m) -
provided there exists a subgoup n and m - returns a tuple with the matched substrings.
group(n,m) is equal to (group(n), group(m)):

>>> import re
>>> mo = re.search("([0-9]+).*: (.*)", "Customer
number: 232454, Date: February 12, 2011")
>>> mo.group()
'232454, Date: February 12, 2011'
>>> mo.group(1)
'232454'
>>> mo.group(2)
'February 12, 2011'
>>> mo.group(1,2)
('232454', 'February 12, 2011')
>>>

97. A very intuitive example are XML or HTML tags. E.g. let's assume we have a file
(called "tags.txt") with content like this:
<composer>Wolfgang Amadeus Mozart</composer>
<author>Samuel Beckett</author>
<city>London</city>
We want to rewrite this text automatically to
composer: Wolfgang Amadeus Mozart
author: Samuel Beckett
city: London

import re
fh = open("tags.txt")
for i in fh:
res = re.search(r"<([a-z]+)>(.*)</\1>",i)
print(res.group(1) + ": " + res.group(2))

98.
import re
l = ["555-8396 Neu, Allison",
"Burns, C. Montgomery",
"555-5299 Putz, Lionel",
"555-7334 Simpson, Homer Jay"]
for i in l:
res = re.search(r"([0-9-]*)\s*([A-Za-z]+),\s+
(.*)", i)
print(res.group(3) + " " + res.group(2) + " "
+ res.group(1))

output -
Allison Neu 555-8396
C. Montgomery Burns
Lionel Putz 555-5299
Homer Jay Simpson 555-7334

99.
Using capturing groups instead of "numbered" capturing groups allows you to assign
descriptive names instead of automatic numbers to the groups. In the following
example, we demonstrate this approach by catching the hours, minutes and seconds
from a UNIX date string.
>>> import re
>>> s = "Sun Oct 14 13:47:03 CEST 2012"
>>> expr = r"\b(?P<hours>\d\d):(?P<minutes>\d\d):
(?P<seconds>\d\d)\b"
>>> x = re.search(expr,s)
>>> x.group('hours')
'13'
>>> x.group('minutes')
'47'
>>> x.start('minutes')
14
>>> x.end('minutes')
16
>>> x.span('seconds')
(17, 19)
>>>

100.COMPREHENSIVE PYTHON EXERCISE

In this comprehensive exercise, we have to bring together the information of two files.
In the first file, we have a list of nearly 15000 lines of post codes with the
corresponding city names plus additional information. Here are some arbitrary lines of
this file:
osm_id ort plz bundesland
1104550 Aach 78267 Baden-Württemberg
...
446465 Freiburg (Elbe) 21729 Niedersachsen
62768 Freiburg im Breisgau 79098 Baden-Württemberg
62768 Freiburg im Breisgau 79100 Baden-Württemberg
62768 Freiburg im Breisgau 79102 Baden-Württemberg
...
454863 Fulda 36037 Hessen
454863 Fulda 36039 Hessen
454863 Fulda 36041 Hessen
...
1451600 Gallin 19258 Mecklenburg-Vorpommern
449887 Gallin-Kuppentin 19386 Mecklenburg-
Vorpommern
10/31/2019 Python Tutorial: Regular Expression
https://www.python-course.eu/python3_re.php 23/27
...
57082 Gärtringen 71116 Baden-Württemberg
1334113 Gartz (Oder) 16307 Brandenburg
...
2791802 Giengen an der Brenz 89522 Baden-
Württemberg
2791802 Giengen an der Brenz 89537 Baden-
Württemberg
...
1187159 Saarbrücken 66133 Saarland
1256034 Saarburg 54439 Rheinland-Pfalz
1184570 Saarlouis 66740 Saarland
1184566 Saarwellingen 66793 Saarland
The other file contains a list of the 19 largest German cities. Each line consists of the
rank, the name of the city, the population, and the state (Bundesland):
1. Berlin 3.382.169 Berlin
2. Hamburg 1.715.392 Hamburg
3. München 1.210.223 Bayern
4. Köln 962.884 Nordrhein-Westfalen
5. Frankfurt am Main 646.550 Hessen
6. Essen 595.243 Nordrhein-Westfalen
7. Dortmund 588.994 Nordrhein-Westfalen
8. Stuttgart 583.874 Baden-Württemberg
9. Düsseldorf 569.364 Nordrhein-Westfalen
10. Bremen 539.403 Bremen
11. Hannover 515.001 Niedersachsen
12. Duisburg 514.915 Nordrhein-Westfalen
13. Leipzig 493.208 Sachsen
14. Nürnberg 488.400 Bayern
15. Dresden 477.807 Sachsen
16. Bochum 391.147 Nordrhein-Westfalen
17. Wuppertal 366.434 Nordrhein-Westfalen
10/31/2019 Python Tutorial: Regular Expression
https://www.python-course.eu/python3_re.php 24/27
18. Bielefeld 321.758 Nordrhein-Westfalen
19. Mannheim 306.729 Baden-Württemberg
Our task is to create a list with the top 19 cities, with the city names accompanied by
the postal code. If you want to test the following program, you have to save the list
above in a file called largest_cities_germany.txt and you have to download and save the
list of German post codes
import re
with open("zuordnung_plz_ort.txt", encoding="utf-
8") as fh_post_codes:
codes4city = {}
for line in fh_post_codes:
res = re.search(r"[\d ]+([^\d]+[az])\
s(\d+)", line)
if res:
city, post_code = res.groups()
if city in codes4city:
codes4city[city].add(post_code)
else:
codes4city[city] = {post_code}
with open("largest_cities_germany.txt",
encoding="utf-8") as fh_largest_cities:
for line in fh_largest_cities:
re_obj = re.search(r"^[0-9]{1,2}\.\s+
([\w\s-]+\w)\s+[0-9]", line)
city = re_obj.group(1)
print(city, codes4city[city])
The output of this file looks like this, but we have left out all but the first three postal
codes for every city:
Berlin {'10715', '13158', '13187', ...}
Hamburg {'22143', '22119', '22523', ...}
München {'80802', '80331', '80807', ...}
Köln {'51065', '50997', '51067', ...}
Frankfurt am Main {'65934', '60529', '60308', ...}
Essen {'45144', '45134', '45309', ... }
Dortmund {'44328', '44263', '44369',...}
Stuttgart {'70174', '70565', '70173', ...}
Düsseldorf {'40217', '40589', '40472', ...}
Bremen {'28207', '28717', '28777', ...}
Hannover {'30169', '30419', '30451', ...}
Duisburg {'47137', '47059', '47228', ...}
Leipzig {'4158', '4329', '4349', ...'}
Nürnberg {'90419', '90451', '90482', ...}
Dresden {'1217', '1169', '1324', ...}
Bochum {'44801', '44892', '44805', ...}
Wuppertal {'42109', '42119', '42287', ...}
Bielefeld {'33613', '33607', '33699', ...}
Mannheim {'68161', '68169', '68167', ...}

101. ANOTHER COMPREHENSIVE EXAMPLE

A regular expression for matching this superset of UK postcodes looks like this:
r"\b[A-Z]{1,2}[0-9R][0-9A-Z]? [0-9][ABD-HJLNP-UWZ]{
2}\b"
The following Python program uses the regexp above:
import re
example_codes = ["SW1A 0AA", # House of Commons
"SW1A 1AA", # Buckingham Palace
"SW1A 2AA", # Downing Street
"BX3 2BB", # Barclays Bank
"DH98 1BT", # British Telecom
"N1 9GU", # Guardian Newspaper
"E98 1TT", # The Times
"TIM E22", # a fake postcode
"A B1 A22", # not a valid
postcode
"EC2N 2DB", # Deutsche Bank
"SE9 2UG", # University of
Greenwhich
"N1 0UY", # Islington, London
"EC1V 8DS", # Clerkenwell, London
"WC1X 9DT", # WC1X 9DT
"B42 1LG", # Birmingham
"B28 9AD", # Birmingham
"W12 7RJ", # London, BBC News
Centre
"BBC 007" # a fake postcode
]

pc_re = r"[A-z]{1,2}[0-9R][0-9A-Z]? [0-9][ABDHJLNP-
UW-Z]{2}"
for postcode in example_codes:
r = re.search(pc_re, postcode)
if r:
print(postcode + " matched!")
else:
print(postcode + " is not a valid
postcode!")

############################################################################################################

PYTEST

102. Test files which pytest will use for testing have to start with test_ or end with
_test.py

103. 
The first file is the file which should be tested. We assume that it is saved as
fibonacci.py:
def fib(n):
old, new = 0, 1
for _ in range(n):
old, new = new, old + new
return old
Now, we have to provide the code for the file test_fibonacci.py. This file will be used by 'pytest':
from fibonacci import fib
def test_fib():
assert fib(0) == 0
assert fib(1) == 1
assert fib(10) == 55
We call pytest in a command shell in the directory where the two file shown above reside:
(base) bernd@moon:~$ pytest
The result of this code can be seen in the following:
============================= test session starts
==============================
platform linux -- Python 3.7.1, pytest-4.0.2, py-1.7.0, pluggy-0.8.0
rootdir: /home/bernd/Dropbox
(Bodenseo)/kurse/python_en/examples/pytest/pytest_ex1, inifile:
plugins: remotedata-0.3.1, openfiles-0.3.1, doctestplus-0.2.0, arraydiff-0.3
collected 1 item
test_fibonacci.py .
[100%]
=========================== 1 passed in 0.01 seconds
===========================

104.
(a) The files to be tested:
	fibonacci.py
	foobar_plus.py
	foobar.py
	The test files:
	test_fibonacci.py

	The test files:
	test_fibonacci.py
	test_foobar_plus.py
	test_foobar.py
	We start 'pytest' in the directory 'ex2' and get the following results:
	$ pytest
	==================== test session starts ======================
	platform linux -- Python 3.7.3, pytest-4.3.1, py-1.8.0, pluggy-0.9.0
	rootdir: /home/bernd/Dropbox (Bodenseo)/websites/pythoncourse.
	eu/examples/pytest/ex2, inifile:
	plugins: remotedata-

 (b) We will select now only the files containing 'plus' and 'fibo'
 	 $ pytest -k 'plus or fibo'
	 ============================= test session starts
	 ==============================
	 platform linux -- Python 3.7.1, pytest-4.0.2, py-1.7.0, pluggy-0.8.0
	 rootdir:

105. MARKERS IN PYTEST

     Test functions can be marked or tagged by decorating them with 'pytest.mark.'.
     Such a marker can be used to select or deselect test functions.
	 You can see the markers which exist for your test suite by typing
	 $ pytest --markers
	 @pytest.mark.openfiles_ignore:
	 @pytest.mark.remote_data:
	 @pytest.mark.internet_off:
	 @pytest.mark.filterwarnings(warning):
	 @pytest.mark.skip(reason=None):
	 @pytest.mark.skipif(condition):
	 @pytest.mark.xfail(condition, reason=None, run=True, raises=None, strict=False):
     @pytest.mark.parametrize(argnames, argvalues):
	 @pytest.mark.usefixtures(fixturename1, fixturename2, ...):
	 @pytest.mark.tryfirst:
	 @pytest.mark.trylast:
	 Above list also contains custom defined markers!
	 
106. REGISTERING MARKERS

	Since pytest version 4.5 markers have to be registered.
	They can be registered in the init file pytest.ini, placed in the test directory.
	We register the markers 'slow' and 'crazy', which we will use in the following example:
	[pytest]
	markers =
	slow: mark a test as a 'slow' (slowly) running test
	crazy: stupid function to test :-)
	We add a recursive and inefficient version rfib to our fibonacci module and mark the corresponding test routine with slow, besides
	this rfib is marked with crazy as well:
	# content of fibonacci.py
	def fib(n):
	old, new = 0, 1
	for i in range(n):	 
	old, new = new, old + new
	return old
	def rfib(n):
	if n == 0:
	return 0
	elif n == 1:
	return 1
	else:
	return rfib(n-1) + rfib(n-2)
	The corresponding test file:
	#content of test_fibonacci.py
	import pytest
	from fibonacci import fib, rfib
	def test_fib():
	assert fib(0) == 0
	assert fib(1) == 1
	assert fib(34) == 5702887
	@pytest.mark.crazy
	@pytest.mark.slow
	def test_rfib():
	assert fib(0) == 0
	assert fib(1) == 1
	assert rfib(34) == 5702887
	Besides this we will add the files foobar.py and test_foobar.py as well. We mark the test functions in test_foobar.py as crazy.
	# content of foobar.py
	def foo():
	return "foo"
	def bar():
	return "bar"
	This is the correponding test file:
	# content of test_foobar.py
	import pytest
	from foobar import foo, bar
	@pytest.mark.crazy
	def test_foo():
	assert foo() == "foo"
	@pytest.mark.crazy
	def test_bar():
	assert bar() == "bar"
	We will start tests now depending on the markers.
	Let's start all tests, which are not marked as slow:
	$ pytest -svv -k "slow"
	===================================== test session starts
	======================================
	platform linux -- Python 3.7.1, pytest-4.0.2, py-1.7.0, pluggy-0.8.0 --
	/home/bernd/anaconda3/bin/python
	cachedir: .pytest_cache
	rootdir: /home/bernd/Dropbox
	(Bodenseo)/kurse/python_en/examples/pytest/ex_tagging, inifile:
	plugins: remotedata-0.3.1, openfiles-0.3.1, doctestplus-0.2.0, arraydiff-0.3
	collected 4 items / 3 deselected
	test_fibonacci.py::test_rfib PASSED
	============================ 1 passed, 3 deselected in 7.05 seconds
	============================
	We will run now only the tests which are not marked as slow or crazy:
	$ pytest -svv -k "not slow and not crazy"
	======================= test session starts =======================
	platform linux -- Python 3.7.1, pytest-4.0.2, py-1.7.0, pluggy-0.8.0 --
	/home/bernd/anaconda3/bin/python
	cachedir: .pytest_cache
	rootdir: /home/bernd/Dropbox
	(Bodenseo)/kurse/python_en/examples/pytest/ex_tagging, inifile:
	plugins: remotedata-0.3.1, openfiles-0.3.1, doctestplus-0.2.0, arraydiff-0.3
	collected 4 items / 3 deselected
	test_fibonacci.py::test_fib PASSED
	===================== 1 passed, 3 deselected in 0.01 seconds
	====================
	 
107. SKIPIF MARKER

	(a)
	
	import pytest
	import sys
	from foobar import foo, bar
	@pytest.mark.skipif(
	sys.version_info[0] == 3 and sys.version_info[1] == 6,
	reason="Python version has to be higher than 3.5!")
	def test_foo():
	assert foo() == "foo"
	@pytest.mark.crazy
	def test_bar():
	assert bar() == "bar"	 

	(b) 
	
	Instead of a conditional skip we can also use an uncoditional skip. This way we can always skip. We can add a reason. The
	following example shows how this can be accomplished by marking the function test_bar with a skip marker. The reason we give is
	that it is "even fooer than foo":
	import pytest
	import sys
	from foobar import foo, bar
	@pytest.mark.skipif(
	sys.version_info[0] == 3 and sys.version_info[1] == 6,
	reason="Python version has to be higher than 3.5!")
	def test_foo():
	assert foo() == "foo"
	@pytest.mark.skip(reason="Even fooer than foo, so we skip!")
	def test_bar():
	assert bar() == "bar"

	If we call pytest on this code, we get the following output:
	$ pytest -v
	================ test session starts ===============
	platform linux -- Python 3.6.9, pytest-5.0.1, py-1.8.0, pluggy-0.12.0 --
	/home/bernd/anaconda3/envs/unittest/bin/python
	cachedir: .pytest_cache
	rootdir: /home/bernd/Dropbox
	(Bodenseo)/kurse/python_en/examples/pytest/ex_tagging2, inifile: pytest.ini
	collected 4 items

108. PARAMETRIZATION WITH MARKERS

	We will demonstrate parametrization with markers with our Fibonacci function.
	# content of fibonacci.py
	def fib(n):
	old, new = 0, 1
	for _ in range(n):
	old, new = new, old + new
	return old
	We write a pytest test function which will test against this fibonacci function with various values:
	# content of the file test_fibonacci.py
	import pytest
	from fibonacci import fib
	@pytest.mark.parametrize(
	'n, res', [(0, 0),
	(1, 1),
	(2, 1),
	(3, 2),
	(4, 3),
	(5, 5),
	(6, 8)])
	def test_fib(n, res):
	assert fib(n) == res
	
	When we call pytest, we get the following results:
	$ pytest -v
	============================ test session starts ============================
	platform linux -- Python 3.6.9, pytest-5.0.1, py-1.8.0, pluggy-0.12.0 --
	/home/bernd/anaconda3/envs/unittest/bin/python
	cachedir: .pytest_cache
	rootdir: /home/bernd/Dropbox
	(Bodenseo)/kurse/python_en/examples/pytest/ex_parametrization1
	collected 7 items
	test_fibonacci.py::test_fib[0-0] PASSED
	[ 14%]
	test_fibonacci.py::test_fib[1-1] PASSED
	[ 28%]
	test_fibonacci.py::test_fib[2-1] PASSED
	[ 42%]
	test_fibonacci.py::test_fib[3-2] PASSED
	[ 57%]
	test_fibonacci.py::test_fib[4-3] PASSED
	[ 71%]
	test_fibonacci.py::test_fib[5-5] PASSED
	[ 85%]
	test_fibonacci.py::test_fib[6-8] PASSED
	[100%]
	https://www.python-course.eu/python3_pytest.php 10/12
	========================== 7 passed in 0.01 seconds =========================
	The numbers inside of the square brackets on front of the word "PASSED" are the values of 'n' and 'res'.

109. Calling "pytest -s -v" will deliver the following output:

110. COMMAND LINE OPTIONS / FIXTURES

	At first, we have to write a file conftest.py with the functions cmdopt and pytest_addoption:
	 
	import pytest
	def pytest_addoption(parser):
	parser.addoption("--cmdopt",
	action="store",
	default="full",
	help="'num' of tests or full")
	@pytest.fixture
	def cmdopt(request):
	return request.config.getoption("--cmdopt")
	The code for our fibonacci test module looks like. The test_fif function has a parameter 'cmdopt' which gets the parameter option:
	from fibonacci import fib
	results = [0, 1, 1, 2, 3, 5, 8, 13, 21,
	34, 55, 89, 144, 233, 377]
	def test_fib(cmdopt):
	if cmdopt == "full":
	num = len(results)
	else:
	num = len(results)
	if int(cmdopt) < len(results):
	num = int(cmdopt)
	for i in range(num):
	assert fib(i) == results[i]
	We can call it now with various options, as we can see in the following:
	$ pytest -q --cmdopt=full -v -s
	============ test session starts ================
	platform linux -- Python 3.6.9, pytest-5.0.1, py-1.8.0, pluggy-0.12.0
	rootdir: /home/bernd/Dropbox
	(Bodenseo)/kurse/python_en/examples/pytest/ex_cmd_line
	collected 1 item
	test_fibonacci.py running 15 tests!
	.
	============= 1 passed in 0.01 seconds ============
	$ pytest -q --cmdopt=6 -v -s
	============= test session starts ==============
	platform linux -- Python 3.6.9, pytest-5.0.1, py-1.8.0, pluggy-0.12.0
	rootdir: /home/bernd/Dropbox
	(Bodenseo)/kurse/python_en/examples/pytest/ex_cmd_line
	collected 1 item
	 
	test_fibonacci.py running 6 tests!
	.
	=========================== 1 passed in 0.01 seconds
	================================
	Let's put an error in our test results:
	results = [0, 1, 1, 2, 3, 1001, 8,…]
	Calling pytest with 'pytest -q --cmdopt=10 -v -s' gives us the following output:
	================== test session starts ================== platform linux -- Python 3.6.9, pytest-5.0.1, py-1.8.0, pluggy-
	0.12.0 rootdir: /home/bernd/Dropbox (Bodenseo)/kurse/python_en/examples/pytest/ex_cmd_line collected 1 item test_fibonacci.py
	running 10 tests! F =============== FAILURES =================== _______________test_fib
	___________________ cmdopt = '10' def test_fib(cmdopt): if cmdopt == "full": num = len(results) else: num = len(results) if
	int(cmdopt) < len(results): num = int(cmdopt) print(f"running {num:2d} tests!") for i in range(num): > assert fib(i) == results[i] E
	assert 5 == 1001 E + where 5 = fib(5) test_fibonacci.py:16: AssertionError ================ 1 failed in 0.03 seconds
	=================	 
	 
111. 
112. 
############################################################################################################

OPERATOR OVERLOADING

1. Operator Overloading means giving extended meaning beyond their predefined operational meaning.

############################################################################################################
2.
# Python program to show use of
# + operator for different purposes.
print(1 + 2)
# concatenate two strings
print("Geeks"+"For")
# Product two numbers
print(3 * 4)
# Repeat the String
print("Geeks"*4)

Output:
3
GeeksFor
12
GeeksGeeksGeeksGeeks

############################################################################################################
3. when we use + operator, the magic method __add__ is automatically invoked in which the operation for
+ operator is defined.

4. 
# Python Program illustrate how 
# to overload an binary + operator 

class A: 
	def __init__(self, a): 
		self.a = a 

	# adding two objects 
	def __add__(self, o): 
		return self.a + o.a 
ob1 = A(1) 
ob2 = A(2) 
ob3 = A("Geeks") 
ob4 = A("For") 

print(ob1 + ob2) 
print(ob3 + ob4) 

Output :

3
GeeksFor

5. 
# Python program to overload 
# a comparison operators 

class A: 
	def __init__(self, a): 
		self.a = a 
	def __gt__(self, other): 
		if(self.a>other.a): 
			return True
		else: 
			return False
ob1 = A(2) 
ob2 = A(3) 
if(ob1>ob2): 
	print("ob1 is greater than ob2") 
else: 
	print("ob2 is greater than ob1") 

6.
Python magic methods or special functions for operator overloading
Binary Operators:
OPERATOR	MAGIC METHOD
+	__add__(self, other)
–	__sub__(self, other)
*	__mul__(self, other)
/	__truediv__(self, other)
//	__floordiv__(self, other)
%	__mod__(self, other)
**	__pow__(self, other)

Comparison Operators :
OPERATOR	MAGIC METHOD
<	__lt__(self, other)
>	__gt__(self, other)
<=	__le__(self, other)
>=	__ge__(self, other)
==	__eq__(self, other)
!=	__ne__(self, other)

Assignment Operators :
OPERATOR	MAGIC METHOD
-=	__isub__(self, other)
+=	__iadd__(self, other)
*=	__imul__(self, other)
/=	__idiv__(self, other)
//=	__ifloordiv__(self, other)
%=	__imod__(self, other)
**=	__ipow__(self, other)

Unary Operators :
OPERATOR	MAGIC METHOD
–	__neg__(self, other)
+	__pos__(self, other)
~	__invert__(self, other)

############################################################################################################
EXCEPTIONAL HANDLING

124.
Let's look at a simple example. Assuming we want to ask the user to enter an integer
number. If we use a input(), the input will be a string, which we have to cast into an
integer. If the input has not been a valid integer, we will generate (raise) a ValueError.
We show this in the following interactive session:
>>> n = int(input("Please enter a number: "))
Please enter a number: 23.5
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
ValueError: invalid literal for int() with base
10: '23.5'
With the aid of exception handling, we can write robust code for reading an integer
from input:
while True:
try:
n = input("Please enter an integer: ")
n = int(n)
break
except ValueError:
print("No valid integer! Please try again
...")
print("Great, you successfully entered an
integer!")

125. A try statement may have more than one except clause for different exceptions. But at
most one except clause will be executed.

126. 
import sys
try:
f = open('integers.txt')
s = f.readline()
i = int(s.strip())
except IOError as e:
errno, strerror = e.args
print("I/O error({0}):
{1}".format(errno,strerror))
# e can be printed directly without using
.args:
# print(e)
except ValueError:
print("No valid integer in line.")
except:
print("Unexpected error:", sys.exc_info()[0])
raise

The except
clause for the IOError specifies a variable "e" after the exception name (IOError). The
variable "e" is bound to an exception instance with the arguments stored in
instance.args.
If we call the above script with a non-existing file, we get the message:
I/O error(2): No such file or directory
And if the file integers.txt is not readable, e.g. if we don't have the permission to read it,
we get the following message:
I/O error(13): Permission denied

127.
An except clause may name more than one exception in a tuple of error names, as we
see in the following example:
try:
f = open('integers.txt')
s = f.readline()
i = int(s.strip())
except (IOError, ValueError):
print("An I/O error or a ValueError occurred")
except:
print("An unexpected error occurred")
raise

128. CUSTOM-MADE EXCEPTIONS

class MyException(Exception):
pass
raise MyException("An exception doesn't always
prove the rule!")

129. ELSE CLAUSE

The try ... except statement has an optional else clause. An else block has to be
positioned after all the except clauses. An else clause will be executed if the try clause
doesn't raise an exception.

python exception_test.py integers.txt

import sys
file_name = sys.argv[1]
text = []
try:
fh = open(file_name, 'r')
except IOError:
print('cannot open', file_name)
else:
text = fh.readlines()
fh.close()
if text:
print(text[100])

############################################################################################################
EXECUTE A PYTHON SCRIPT

130. The truth is: Python is both an interpreted and a compiled language.

131. People would assume that the compiler
translates the Python code into machine language. Python code is translated into
intermediate code, which has to be executed by a virtual machine, known as the PVM,
the Python virtual machine.

132. For whatever reason you want to compile a python program manually? No problem. It
can be done with the module py_compile, either using the interpreter shell

>>> import py_compile
>>>
py_compile.compile('my_first_simple_program.py')
>>>
or using the following command at the shell prompt
python -m py_compile my_first_simple_program.py
Either way, you may notice two things: First, there will be a new subdirectory
"__pycache__", if it hasn't already existed. You will find a file
"my_first_simple_script.cpython-34.pyc" in this subdirectory. This is the compiled
version of our file in byte code.

133. You can also automatically compile all Python files using the compileall module.

monty@python:~/python$ python -m compileall .
Listing . ...

134. Some newbies to Python wonder sometimes where these ominous files with the .pyc suffix might come
from. If Python has write-access for the directory where the Python program resides, it
will store the compiled byte code in a file that ends with a .pyc suffix. If Python has no
write access, the program will work anyway. The byte code will be produced but
discarded when the program exits.

135. Whenever a Python program is called, Python will check, if a compiled version with the
.pyc suffix exists. This file has to be newer than the file with the .py suffix. If such a file
exists, Python will load the byte code, which will speed up the start up time of the
script. If there exists no byte code version, Python will create the byte code before it
starts the execution of the program. Execution of a Python program means execution of
the byte code on the Python Virtual Machine (PVM).

Source code ---> Byte code ---> Python Virtual Machine

136. RUNNABLE SCRIPTS UNDER LINUX

A Python script can also be started like any other script under Linux, e.g. Bash scripts.
Two steps are necessary for this purpose:

1. The shebang line #!/usr/bin/env python3 has to be added as the first line of your
Python code file. Alternatively, this line can be #!/usr/bin/python3, if this is the
location of your Python interpreter. By instead using env as in the first shebang
line, the interpreter is searched for and located at the time the script is run. This
makes the script more portable. Yet, it also suffers from the same problem: The
path to env may also be different on a per-machine basis.

2. The file has to be made executable: The command "chmod +x scriptname" has to
be executed on a Linux shell, e.g. bash. "chmod 755 scriptname" can also be used
to make your file executable. In our example:
$ chmod +x my_first_simple_program.py

############################################################################################################

FILE MANAGEMENT

137. The "r" is optional. An open() command with just a file name is opened for reading per
default. The open() function returns a file object, which offers attributes and methods.
fobj = open("ad_lesbiam.txt")

138. 
fobj = open("ad_lesbiam.txt")
for line in fobj:
	print(line.rstrip())

fobj.close()

139. You will often find the with statement for reading and writing files. The advantage is
that the file will be automatically closed after the indented block after the with has
finished execution:

with open("example.txt", "w") as fh:
	fh.write("To write or not to write\nthat is
	the question!\n")

140.
>>> poem = open("ad_lesbiam.txt").readlines()
>>> print(poem)
['V. ad Lesbiam \n', '\n', 'VIVAMUS mea Lesbia,
atque amemus,\n', 'rumoresque senum severiorum\n',
'omnes unius aestimemus assis!\n', 'soles occidere
et redire possunt:\n', 'nobis cum semel occidit
breuis lux,\n', 'nox est perpetua una
dormienda.\n', 'da mi basia mille, deinde
centum,\n', 'dein mille altera, dein secunda
centum,\n', 'deinde usque altera mille, deinde
centum.\n', 'dein, cum milia multa fecerimus,\n',
'conturbabimus illa, ne sciamus,\n', 'aut ne quis
malus inuidere possit,\n', 'cum tantum sciat esse
basiorum.\n', '(GAIUS VALERIUS CATULLUS)']
>>> print(poem[2])
VIVAMUS mea Lesbia, atque amemus,

141.
Another convenient way to read in a file might be the method read() of open. With this
method we can read the complete file into a string, as we can see in the next example:
>>> poem = open("ad_lesbiam.txt").read()
>>> print(poem[16:34])
VIVAMUS mea Lesbia
>>> type(poem)
<type 'str'>
>>>

142. To work with seek, we will often need the method tell,
which "tells" us the current position.When we have just opened a file, it will be zero.

143.
>>> fh = open("buck_mulligan.txt")
>>> fh.tell()
0
>>> fh.read(7)
'Stately'
>>> fh.tell()
7
>>> fh.read()
', plump Buck Mulligan came from the stairhead,
bearing a bowl of\nlather on which a mirror and a
razor lay crossed.\n'
>>> fh.tell()
122
>>> fh.seek(9)
9
>>> fh.read(5)
'plump'




############################################################################################################
FUNCTIONS

144. Using functions usually enhances the comprehensibility and quality of the program. It also lowers the
cost for development and maintenance of the software.

145. If the return statement is without an expression, the special value None is returned.

146. If there is no return statement in the function code, the function ends, when the control flow reaches
the end of the function body and the value "None" will be returned.

147. The first statement in the body of a function is usually a string, which can be accessed
with function_name.__doc__
This statement is called Docstring.
Example:
def Hello(name="everybody"):
""" Greets a person """
print("Hello " + name + "!")
print("The docstring of the function Hello: " +
Hello.__doc__)
The output:
The docstring of the function Hello: Greets a
person

148. KEYWORD PARAMETERS

def sumsub(a, b, c=0, d=0):
return a - b + c - d
print(sumsub(12,4))
print(sumsub(42,15,d=10))

Keyword parameters can only be those, which are not used as positional arguments. We
can see the benefit in the example. If we hadn't keyword parameters, the second call to
function would have needed all four arguments, even though the c needs just the default
value:
print(sumsub(42,15,0,10))

149. A function can return exactly one value, or we should better say one object.

150. Variable names are by default local to the function, in which they get defined.

def f():
print(s)
s =
"Python"
f()
Output:
Python

def f():
s =
"Perl"
print(s)
Output:
Perl
Python

151.
s =
"Python"
f()
print(s)
def f():
print(s)
s =
"Perl"
print(s)
s =
"Python"
f()
print(s)
If we execute the previous script, we get the
error message:
UnboundLocalError: local variable 's'
referenced before assignment
The variable s is ambigious in f(), i.e. in the
first print in f() the global s could be used
with the value "Python". After this we define
a local variable s with the assignment s =
"Perl"
def f():
global s
print(s)
s =
"dog"
print(s)
s = "cat"
f()
print(s)

152. ARBITRARY NUMBER OF PARAMETERS

def arithmetic_mean(first, *values):
""" This function calculates the arithmetic
mean of a non-empty
arbitrary number of numerical values """
return (first + sum(values)) / (1 +
len(values))

x = [3, 5, 9]
arithmetic_mean(*x)
You cannot call it with arithmetic_mean(x) because "arithmetic_mean" can't cope with a list.

153. ARBITRARY NUMBER OF KEYWORD PARAMETERS

>>> def f(a,b,x,y):
... print(a,b,x,y)
…
>>> d = {'a':'append',
'b':'block','x':'extract','y':'yes'}
>>> f(**d)
('append', 'block', 'extract', 'yes')

############################################################################################################
GLOBAL, LOCAL AND NON LOCAL VARIABLES

154. Global variables are generally bad practice and should be avoided.

155. When you define variables inside a function definition, they are local to this function
by default. This means that anything you will do to such a variable in the body of the
function will have no effect on other variables outside of the function, even if they have
the same name. This means that the function body is the scope of such a variable, i.e.
the enclosing context where this name with its values is associated.

156. All variables have the scope of the block, where they are declared and defined in. They
can only be used after the point of their declaration.

157. 
def f():
s = "I love London!"
print(s)
s = "I love Paris!"
f()
print(s)
The output looks like this:
I love London!
I love Paris!

158. Ambiguous situation.
A variable can't be both local and global inside of a function.

>>> def f():
... print(s)
... s = "I love London!"
... print(s)
...
>>> s = "I love Paris!"
>>> f()
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
File "<stdin>", line 2, in f
UnboundLocalError: local variable 's' referenced
before assignment
>>>

159.
def f():
global s
print(s)
s = "Only in spring, but London is great as
well!"
print(s)
s = "I am looking for a course in Paris!"
f()
print(s)

OUTPUT:
I am looking for a course in Paris!
Only in spring, but London is great as well!
Only in spring, but London is great as well!

160.
Local variables of functions can't be accessed from outside, when the function call has
finished:
def f():
s = "I am globally not known"
print(s)
f()
print(s) --> NameError: name 's' is not defined

161.
def foo(x, y):
global a
a = 42
x,y = y,x
b = 33
b = 17
c = 100
print(a,b,x,y)
a, b, x, y = 1, 15, 3,4
foo(17, 4)
print(a, b, x, y)

The output looks like this:
42 17 4 17
42 15 3 4

162. GLOBAL VARIABLES IN NESTED FUNCTIONS

This means that the global keyword in nested functions does
not affect the namespace of their enclosing namespace!

def f():
city = "Hamburg"
def g():
global city
city = "Geneva"
print("Before calling g: " + city)
print("Calling g now:")
g()
print("After calling g: " + city)
f()
print("Value of city in main: " + city)
This program returns the following results:
Before calling g: Hamburg
Calling g now:
After calling g: Hamburg
Value of city in main: Geneva

163.
def f():
nonlocal city
print(city)
city = "Frankfurt"
f()

We get the following error:
File "/home/bernd/nested_globals.py", line 2
nonlocal city
^
SyntaxError: no binding for nonlocal 'city' found

164.
def f():
city = "Munich"
def g():
nonlocal city
city = "Zurich"
print("Before calling g: " + city)
print("Calling g now:")
g()
print("After calling g: " + city)
city = "Stuttgart"
f()
print("'city' in main: " + city)
Calling the previous program results in the following output:
Before calling g: Munich
Calling g now:
After calling g: Zurich
'city' in main: Stuttgart

165.
def f():
#city = "Munich"
def g():
nonlocal city
city = "Zurich"
print("Before calling g: " + city)
print("Calling g now:")
g()
print("After calling g: " + city)
city = "Stuttgart"
f()
print("'city' in main: " + city)
We get the following error message:
File "/home/bernd/nested_globals.py", line 4
nonlocal city
^
SyntaxError: no binding for nonlocal 'city' found

166.
def f():
#city = "Munich"
def g():
global city
city = "Zurich"
print("Before calling g: " + city)
print("Calling g now:")
g()
print("After calling g: " + city)
city = "Stuttgart"
f()
print("'city' in main: " + city)
This leads to the following output:
Before calling g: Stuttgart
Calling g now:
After calling g: Zurich
'city' in main: Zurich
Yet there is a huge difference: The value of the global x is changed now!

############################################################################################################
HISTORY OF PYTHON

167.
In an interview with Bill Venners1, Guido van Rossum said: "In the early 1980s, I worked as an implementer
on a team building a language called ABC at Centrum voor Wiskunde en Informatica
(CWI). I don't know how well people know ABC's influence on Python. I try to
mention ABC's influence because I'm indebted to everything I learned during that
project and to the people who worked on it."
Later on in the same Interview, Guido van Rossum continued: "I remembered all my
experience and some of my frustration with ABC. I decided to try to design a simple
scripting language that possessed some of ABC's better properties, but without its
problems. So I started typing. I created a simple virtual machine, a simple parser, and a
simple runtime. I made my own version of the various ABC parts that I liked.
I created a basic syntax, used indentation for statement grouping instead of curly braces or beginend
blocks, and developed a small number of powerful data types: a hash table (or
dictionary, as we call it), a list, strings, and numbers.

168. what about the name "Python" ?
Guido van Rossum, the creator of Python, wrote in 1996 about the origin of the name of his
programming language1: "Over six years ago, in December 1989, I was looking for a
'hobby' programming project that would keep me occupied during the week around
Christmas. My office ... would be closed, but I had a home computer, and not much else
on my hands. I decided to write an interpreter for the new scripting language I had been
thinking about lately: a descendant of ABC that would appeal to Unix/C hackers. I
chose Python as a working title for the project, being in a slightly irreverent mood (and
a big fan of Monty Python's Flying Circus)."

169. Guido Van Rossum published the first version of Python code (version 0.9.0) at
alt.sources in February 1991.

############################################################################################################
INHERITANCE

170. Inheritance supports code reusability. The methods or generally speaking the software inherited by a subclass
is considered to be reused in the subclass.

171.(a) The class from which a class inherits is called the parent or superclass.
    (b) A class which inherits from a superclass is called a subclass, also called heir class or child class.

172. DIFFERENCE BETWEEN TYPE AND ISINSTANCE

class Robot:
    def __init__(self, name):
	self.name = name
    def say_hi(self):
	print("Hi, I am " + self.name)
    class PhysicianRobot(Robot):
	pass
		
x = Robot("Marvin")
y = PhysicianRobot("James")
print(x, type(x))
print(y, type(y))

y.say_hi()
<__main__.Robot object at 0x7fd0080b3ba8> <class
'__main__.Robot'>
<__main__.PhysicianRobot object at 0x7fd0080b3b70>
<class '__main__.PhysicianRobot'>
Hi, I am James

x = Robot("Marvin")
y = PhysicianRobot("James")
print(isinstance(x, Robot), isinstance(y, Robot))
print(isinstance(x, PhysicianRobot))
print(isinstance(y, PhysicianRobot))
print(type(y) == Robot, type(y) == PhysicianRobot)
True True
False
True
False True

Now it should be clear, why PEP 8, the official Style Guide for Python code, says:
"Object type comparisons should always use isinstance() instead of comparing types
directly."

173. Now it should be clear, why PEP 8, the official Style Guide for Python code, says:
"Object type comparisons should always use isinstance() instead of comparing types
directly."

174. OVERRIDING

class Robot:
    def __init__(self, name):
        self.name = name

    def say_hi(self):
        print("Hi, I am " + self.name)

class PhysicianRobot(Robot):
    def say_hi(self):
        print("Everything will be okay! ")
        print(self.name + " takes care of you!")

y = PhysicianRobot("James")
y.say_hi()

O/P :
Everything will be okay! 
James takes care of you!
>>> 

175. 
class Robot:
def __init__(self, name):
self.name = name
def say_hi(self):
print("Hi, I am " + self.name)

M1
--
class PhysicianRobot(Robot):
def say_hi(self):
super().say_hi()
print("and I am a physician!")
doc = PhysicianRobot("Dr. Frankenstein")
doc.say_hi()

O/P
Hi, I am Dr. Frankenstein
and I am a physician!

M2
--
class PhysicianRobot(Robot):
def say_hi(self):
Robot.say_hi(self)
print("and I am a physician!")
doc = PhysicianRobot("Dr. Frankenstein")
doc.say_hi()

O/P
Hi, I am Dr. Frankenstein
and I am a physician!

super is not realls necessary in this case. One could argue that it makes the code more
maintainable, because we could change the name of the parent class, but this is seldom
done anyway in existing classes. The real benefit of super shows when we use it with
multiple inheritance.

DISTINCTION BETWEEN OVERWRITING, OVERLOADING AND OVERRIDING

176. OVERWRITING
If we overwrite a function, the original function will be gone. The function will be
redefined.

def f(x):
return x + 42
print(f(3))
# f will be overwritten (or redefined) in the
following:
def f(x):
return x + 43
print(f(3))
45
46

177. OVERLOADING
Overloading is the ability to define a function with the same name multiple times.
https://www.geeksforgeeks.org/python-method-overloading/

In the above code we have defined two product method, but we can only use the second product method, as python does not
supports method overloading. We may define many method of same name and different argument but we can only use the latest
defined method. Calling the other method will produce an error. Like here calling product(4, 5) will produce an error as
the latest defined product method takes three arguments.

178. OVERRIDING
https://www.geeksforgeeks.org/method-overriding-in-python/
Method overriding is an ability of any object-oriented programming language that allows a subclass or child class to provide
a specific implementation of a method that is already provided by one of its super-classes or parent classes. 

# Program to define the use of super() 
# function in multiple inheritance 
class GFG1: 
	def __init__(self): 
		print('HEY !!!!!! GfG I am initialised(Class GEG1)') 
	
	def sub_GFG(self, b): 
		print('Printing from class GFG1:', b) 
	
# class GFG2 inherits the GFG1 
class GFG2(GFG1): 
	def __init__(self): 
		print('HEY !!!!!! GfG I am initialised(Class GEG2)') 
		super().__init__() 
	
	def sub_GFG(self, b): 
		print('Printing from class GFG2:', b) 
		super().sub_GFG(b + 1) 
	
# class GFG3 inherits the GFG1 ang GFG2 both 
class GFG3(GFG2): 
	def __init__(self): 
		print('HEY !!!!!! GfG I am initialised(Class GEG3)') 
		super().__init__() 
	
	def sub_GFG(self, b): 
		print('Printing from class GFG3:', b) 
		super().sub_GFG(b + 1) 
	
	
# main function 
if __name__ == '__main__': 
	
	# created the object gfg 
	gfg = GFG3() 
	
	# calling the function sub_GFG3() from class GHG3 
	# which inherits both GFG1 and GFG2 classes 
	gfg.sub_GFG(10) 

OUTPUT
HEY !!!!!! GfG I am initialised(Class GEG3)
HEY !!!!!! GfG I am initialised(Class GEG2)
HEY !!!!!! GfG I am initialised(Class GEG1)
Printing from class GFG3: 10
Printing from class GFG2: 11
Printing from class GFG1: 12

############################################################################################################
THE INTERPRETER , AN INTERACTIVE SHELL

179.
Similarly, a shell in operating systems lies between the kernel
of the operating system and the user.

>>> 3 + 2 * 4
11
>>>
The most recent output value is automatically stored by the interpreter in a special variable
with the name "_". So we can print the output from the recent example again by typing an
underscore after the prompt:
>>> _
11
>>>
The underscore can be used in other expressions like any other variable:
>>> _ * 3
33
>>>

The underscore variable is only available in the Python shell. It's NOT available in Python
scripts or programs.

180.
Multiplication on strings is defined, which is essentially a multiple concatenation:
>>> ".-." * 4
'.-..-..-..-.'
>>>

############################################################################################################
INHERITANCE EXAMPLE

181.
THE CLOCK CLASS

class Clock(object):
    def __init__(self,hours=0, minutes=0,
    seconds=0):
        self.__hours = hours
        self.__minutes = minutes
        self.__seconds = seconds

    def set(self,hours, minutes, seconds=0):
        self.__hours = hours
        self.__minutes = minutes
        self.__seconds = seconds

    def tick(self):
        """ Time will be advanced by one second"""
        if self.__seconds == 59:
            self.__seconds = 0
            if (self.__minutes == 59):
                self.__minutes = 0
                self.__hours = 0 if self.__hours==23 else self.__hours + 1
            else:
                self.__minutes += 1
        else:
            self.__seconds += 1

    def display(self):
        print("%d:%d:%d" % (self.__hours,
        self.__minutes, self.__seconds))

    def __str__(self):
        return "%2d:%2d:%2d" % (self.__hours,
        self.__minutes, self.__seconds)

x = Clock()
print(x)
for i in range(1000):
    x.tick()
print(x)

#############################

OUTPUT
 0: 0: 0
 0:16:40
>>> 

THE CALENDAR CLASS

THE CALENDAR-CLOCK CLASS

############################################################################################################
INPUT FROM KEYBOARD

############################################################################################################
LAMBDA, FILTER, REDUCE AND MAP

182. If Guido van Rossum, the author of the programming language Python, had got his will, this chapter would
be missing in our tutorial.

183. We can see the result: lambda, map() and filter() are still part of core Python. Only
reduce() had to go; it moved into the module functools.

His reasoning for dropping them is like this:
- There is an equally powerful alternative to lambda, filter, map and reduce, i.e. list comprehension
- List comprehension is more evident and easier to understand
- Having both list comprehension and "Filter, map, reduce and lambda" is transgressing the Python motto
  "There should be one obvious way to solve a problem".
  
184. Some like it, others hate it and many are afraid of the lambda operator. 
     The lambda feature was added to Python due to the demand from Lisp programmers.

185. The general syntax of a lambda function is quite simple:
     lambda argument_list: expression
     
186. The argument list consists of a comma separated list of arguments and the expression is
     an arithmetic expression using these arguments. You can assign the function to a
     variable to give it a name.
     
     The following example of a lambda function returns the sum of its two arguments:
     >>> sum = lambda x, y : x + y
     >>> sum(3,4)
     7
     >>>
     
187. THE MAP() FUNCTION

As we have mentioned earlier, the advantage of the lambda operator can be seen when
it is used in combination with the map() function.
map() is a function which takes two arguments:

r = map(func, seq)

The first argument func is the name of a function and the second a sequence (e.g. a list)
seq. map() applies the function func to all the elements of the sequence seq.

With Python 3, map() returns an iterator.

188.
The following example illustrates the way of working of map():
>>> def fahrenheit(T):
... return ((float(9)/5)*T + 32)
...
>>> def celsius(T):
... return (float(5)/9)*(T-32)
...
>>> temperatures = (36.5, 37, 37.5, 38, 39)
>>> F = map(fahrenheit, temperatures)
>>> C = map(celsius, F)
>>>
>>> temperatures_in_Fahrenheit =
list(map(fahrenheit, temperatures))
>>> temperatures_in_Celsius = list(map(celsius,
temperatures_in_Fahrenheit))
>>> print(temperatures_in_Fahrenheit)
[97.7, 98.60000000000001, 99.5, 100.4, 102.2]
>>> print(temperatures_in_Celsius)
[36.5, 37.00000000000001, 37.5, 38.00000000000001,
39.0]
>>>

189.
By using lambda, we wouldn't have had
to define and name the functions fahrenheit() and celsius(). You can see this in the
following interactive session:
>>> C = [39.2, 36.5, 37.3, 38, 37.8]
>>> F = list(map(lambda x: (float(9)/5)*x + 32,
C))
>>> print(F)
[102.56, 97.7, 99.14, 100.4, 100.03999999999999]
>>> C = list(map(lambda x: (float(5)/9)*(x-32),
F))
>>> print(C)
[39.2, 36.5, 37.300000000000004,
38.00000000000001, 37.8]
>>>

190. FILTERING

The function

filter(function, sequence)

offers an elegant way to filter out all the elements of a sequence "sequence", for which
the function function returns True. i.e. an item will be produced by the iterator result of
filter(function, sequence) if item is included in the sequence "sequence" and if
function(item) returns True.

>>> fibonacci = [0,1,1,2,3,5,8,13,21,34,55]
>>> odd_numbers = list(filter(lambda x: x % 2,
fibonacci))
>>> print(odd_numbers)
[1, 1, 3, 5, 13, 21, 55]
>>> even_numbers = list(filter(lambda x: x % 2 ==
0, fibonacci))
>>> print(even_numbers)
[0, 2, 8, 34]
>>>
>>>
>>> # or alternatively:
...
>>> even_numbers = list(filter(lambda x: x % 2 -1,
fibonacci))
>>> print(even_numbers)
[0, 2, 8, 34]
>>>

191. Guido van Rossum hates reduce().

192. The function 
     reduce(func, seq)
     continually applies the function func() to the sequence seq. It returns a single value.

193.
>>> import functools
>>> functools.reduce(lambda x,y: x+y,
[47,11,42,13])
113
>>>

194. EXAMPLES OF REDUCE()

a. Determining the maximum of a list of numerical values by using reduce:
>>> from functools import reduce
>>> f = lambda a,b: a if (a > b) else b
>>> reduce(f, [47,11,42,102,13])
102
>>>

b. Calculating the sum of the numbers from 1 to 100:
>>> from functools import reduce
>>> reduce(lambda x, y: x+y, range(1,101))
5050

############################################################################################################
MAGIC METHODS AND OPERATOR OVERLOADING

195. Magic methods methods are sometimes called dunder methods!

196. When you create an instance x of
a class A with the statement "x = A()", Python will do the necessary calls to __new__
and __init__.

197. The __call__ method enables Python programmers to write classes where the instances behave like functions.
     Both functions and the instances of such classes are called callables.
     
198. The mechanism works like this: If we have an expression "x + y" and x is an instance of
class K, then Python will check the class definition of K. If K has a method __add__ it
will be called with x.__add__(y), otherwise we will get an error message.

199. OVERVIEW OF MAGIC METHODS

BINARY OPERATORS
Operator Method
+ object.__add__(self, other)
- object.__sub__(self, other)
* object.__mul__(self, other)
// object.__floordiv__(self, other)
/ object.__truediv__(self, other)
% object.__mod__(self, other)
** object.__pow__(self, other[, modulo])
<< object.__lshift__(self, other)
>> object.__rshift__(self, other)
& object.__and__(self, other)
^ object.__xor__(self, other)
| object.__or__(self, other)

EXTENDED ASSIGNMENTS
Operator Method
+= object.__iadd__(self, other)
-= object.__isub__(self, other)
*= object.__imul__(self, other)
/= object.__idiv__(self, other)
//= object.__ifloordiv__(self, other)
%= object.__imod__(self, other)
**= object.__ipow__(self, other[, modulo])
<<= object.__ilshift__(self, other)
>>= object.__irshift__(self, other)
&= object.__iand__(self, other)
^= object.__ixor__(self, other)
|= object.__ior__(self, other)

UNARY OPERATORS
Operator Method
- object.__neg__(self)
+ object.__pos__(self)
abs() object.__abs__(self)
~ object.__invert__(self)
complex() object.__complex__(self)
int() object.__int__(self)
long() object.__long__(self)
float() object.__float__(self)
oct() object.__oct__(self)
hex() object.__hex__(self

COMPARISON OPERATORS
Operator Method
< object.__lt__(self, other)
<= object.__le__(self, other)
== object.__eq__(self, other)
!= object.__ne__(self, other)
>= object.__ge__(self, other)
> object.__gt__(self, other)

200. 

>>> from unit_conversions import Length
>>> L = Length
>>> print(L(2.56,"m") + L(3,"yd") + L(7.8,"in") +
L(7.03,"cm"))
5.57162
>>>

class Length:
    __metric = {"mm" : 0.001, "cm" : 0.01, "m" :1, "km" : 1000,
                "in" : 0.0254, "ft" : 0.3048, "yd": 0.9144,
                "mi" : 1609.344 }
        
    def __init__(self, value, unit = "m" ):
        self.value = value
        self.unit = unit

    def Converse2Metres(self):
        return self.value * Length.__metric[self.unit]
    
    def __add__(self, other):
        l = self.Converse2Metres() + other.Converse2Metres()
        return Length(l / Length.__metric[self.unit], self.unit )

    def __str__(self):
        return str(self.Converse2Metres())

    def __repr__(self):
        return "Length(" + str(self.value) + ", '" + self.unit + "')"
    
if __name__ == "__main__":
    x = Length(4)
    print(x)
    y = eval(repr(x))
    z = Length(4.5, "yd") + Length(1)
    print(repr(z))
    print(z)

4
Length(5.593613298337708, 'yd')
5.1148

We use the method__iadd__ to implement the extended assignment:
def __iadd__(self, other):
    l = self.Converse2Metres() + other.Converse2Metres()
    self.value = l / Length.__metric[self.unit]
    return self

Now we are capable to write the following assignments:
x += Length(1)
x += Length(4, "yd")

def __add__(self, other):
    if type(other) == int or type(other) == float:
        l = self.Converse2Metres() + other
    else:
	l = self.Converse2Metres() + other.Converse2Metres()
	return Length(l / Length.__metric[self.unit], self.unit )

def __iadd__(self, other):
    if type(other) == int or type(other) == float:
        l = self.Converse2Metres() + other
    else:
        l = self.Converse2Metres() + other.Converse2Metres()
    self.value = l / Length.__metric[self.unit]
    return self
 
>>> from unit_conversions import Length
>>> x = Length(3, "yd") + 5
>>> x = 5 + Length(3, "yd")
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
TypeError: unsupported operand type(s) for +:
'int' and 'Length'
>>>

def __radd__(self, other):
if type(other) == int or type(other) ==
float:
l = self.Converse2Metres() +
otherLength.__radd__(Length(3, "yd"), 5)
else:
l = self.Converse2Metres() +
other.Converse2Metres()
return Length(l /
Length.__metric[self.unit], self.unit )

def __radd__(self, other):
return Length.__add__(self,other)

200. EXERCISES
1. Write a class with the name Ccy, similar to the previously defined Length class.
Ccy should contain values in various currencies, e.g. "EUR", "GBP" or "USD". An instance
should contain the amount and the currency unit.
The class, you are going to design as an excercise, might be best described with the
following example session:

>>> from currencies import Ccy
>>> v1 = Ccy(23.43, "EUR")
>>> v2 = Ccy(19.97, "USD")
>>> print(v1 + v2)
32.89 EUR
>>> print(v2 + v1)
31.07 USD
>>> print(v1 + 3) # an int or a float is
considered to be a EUR value
27.43 EUR
>>> print(3 + v1)
27.43 EUR
>>>

201. STANDARD CLASSES AS BASE CLASSES
     It's possible to use standard classes - like int, float, dict or lists - as base classes as well.
     
     We extend the list class by adding a push method:
     class Plist(list):
         def __init__(self, l):
             list.__init__(self, l)
         def push(self, item):
             self.append(item)

     if __name__ == "__main__":
         x = Plist([3,4])
         x.push(47)
         print(x)

This means that all the previously introduced binary and extended assignment operators
exist in the "reversed" version as well:
__radd__
__rsub__
__rmul__
...
and so on

202. THE __CALL__ METHOD
The __call__ method can be used to turn the instances of the class into callables.
Functions are callable objects. A callable object is an object which can be used and
behaves like a function but might not be a function. By using the __call__ method it is
possible to define classes in a way that the instances will be callable objects. The
__call__ method is called, if the instance is called "like a function", i.e. using brackets.
The following example defines a class with which we can create abitrary polynomial
functions:

class Polynomial:
def __init__(self, *coefficients):
self.coefficients = coefficients[::-1]
def __call__(self, x):
res = 0
for index, coeff in
enumerate(self.coefficients):
res += coeff * x** index
return res
# a constant function
p1 = Polynomial(42)
# a straight Line
p2 = Polynomial(0.75, 2)
# a third degree Polynomial
p3 = Polynomial(1, -0.5, 0.75, 2)
for i in range(1, 10):
print(i, p1(i), p2(i), p3(i))

These are the results of the previous function:
1 42 2.75 3.25
2 42 3.5 9.5
3 42 4.25 26.75
4 42 5.0 61.0
5 42 5.75 118.25
6 42 6.5 204.5
7 42 7.25 325.75
8 42 8.0 488.0
9 42 8.75 697.25

############################################################################################################
MEMOIZATION WITH DECORATORS

203. Memoisation is a technique used in computing to speed up programs.
This is accomplished by memorizing the calculation results of processed input such as the results of function
calls. If the same input or a function call with the same parameters is used, the previously stored results
can be used again and unnecessary calculation are avoided.

204. memoize() takes a function as an argument. The function memoize uses a dictionary "memo" to store the
function results. Though the variable "memo" as well as the function "f" are local to
memoize, they are captured by a closure through the helper function which is returned
as a reference by memoize(). So, the call memoize(fib) returns a reference to the
helper() which is doing what fib() would do on its own plus a wrapper which saves the
calculated results.

205. 
def memoize(f):
  memo = {}
  def helper(x):
    if x not in memo:
      memo[x] = f(x)
    return memo[x]
  return helper

def fib(n):
  if n == 0:
    return 0
  elif n == 1:
    return 1
  else:
    return fib(n-1) + fib(n-2)

fib = memoize(fib)
print(fib(40))

############################################################################################################

PYTHON ESSENTIAL TRAINING
https://www.linkedin.com/learning/python-essential-training-2/exercise-files

1.
>>> import this
The Zen of Python, by Tim Peters

Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you're Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let's do more of those!
>>> 

2. Everything is an object.

3. print is a function.

4. All text is now unicode.

5. Question 2 of 2
Why should you select UTF-8 as the default editor encoding?

You are correct!
so it can match the Unicode standard of Python 3

6. Shebang line

7.  So type is a built-in function that prints the type of a value or variable.
And so when I save and run this you'll notice that it says that the type is class 'int'.
That's the integer type. It's one of the built-in types.
Python uses a form of dynamic typing sometimes called duck typing where the type of a value
is determined by the value itself. In other words, if it walks like a duck, it's a duck.
So if I change this value to say 7.0 and I save and run it, you see now it's class 'float'.
So it's a floating point number.

8. In Python 3, all types are classes, even the built-in types.

9.  There is no difference between single quotes and double quotes in Python.
In some languages double quotes are interpolated, single quotes are not, or
there may be other distinctions. In Python, there is no difference whatsoever.
In fact, you can even do it this way. You can use three single quotes.
And if I save and run you'll see there's no difference. What that allows you to do,
though, is to put things on several lines. So, using three quotes you can actually make
a multi-line string. And if I save and run this, you see that the result here, and I'll
open this up, says x is seven with lots of newlines and before and after it. And those single
quotes can be double quotes as well. So, you'll often see this. These triple quotes are usually
made out of double quotes, I know that seems to be the style that most often people use. So,
if I save and run this, you see our result is still the same. But for now, we're going to go
right back to my style choice. And again, it's good to have a default style and stick to it.
For my part, I tend to use the single quotes. 

10. 
a = 8
b = 9
x = f'seven {a} {b}'
print('x is {}'.format(x))
print(type(x))

11. 
from decimal import *
a = Decimal('.10')
b = Decimal('.30')
x = a + a + a - b 
print('x is {}'.format(x))
print(type(x))

12. 
x = True
print('x is {}'.format(x))
print(x)
print(type(x))

O / P :
x is True                                                                                                               
True                                                                                                                    
<class 'bool'> 

13. 
x = None
print('x is {}'.format(x))
print(x)
print(type(x))

O / P :
x is None                                                                                                             
None                                                                                                                  
<class 'NoneType'> 
 
14. 
x = None
print('x is {}'.format(x))
print(x)
print(type(x))

if x:
    print('True')
else:
    print('False')
	
O / P :
x is None                                                                                                             
None                                                                                                                  
<class 'NoneType'>                                                                                                    
False 

	a. None evaluates to False
	b. 0  evaluates to False
	c. Empty string evaluates to False.

15. 

Like the tuple, a range is not mutable, If I try to say X sub two equals 42,
save and run, I get this error, "TypeError: 'range' object "does not support item
assignment," because it's immutable. If I want a mutable list, I simply construct
a list with the results from range using the list constructor, like this, and save and run it.

x = range(10)
x[2] = 42
for i in x:
    print('i is {}'.format(i))
	
O / P :
Traceback (most recent call last):                                                                                    
  File "main.py", line 2, in <module>                                                                                 
    x[2] = 42                                                                                                         
TypeError: 'range' object does not support item assignment

16. And dictionaries are mutable.

17. In Python, everything is an object.

18. 
You have the following tuples. Which condition evaluates to a true statement?
 

a=('0',1,'0',[1,'0'])
b=('0',1,'0',[1,'0'])


if (type(a)==type(b)):
if (id(a[0])==id(b[2])):
all of these answers     <---
if (a==b):

19. if '0': ==> evaluates to True

20. 
Is there a difference between the strings '{1} {0}'.format('a','b') and f'{"b"} {"a"}'?

You are correct!
These strings are actually exactly the same.

21. 
x = (1, 'two', 3.0, [4, 'four'], 5)
y = (1, 'two', 3.0, [4, 'four'], 5)
print('x is {}'.format(x))
print(id(x))
print(id(y))

print(id(x[0]))
print(id(y[0]))

if isinstance(x, tuple):
    print('yep')
elif isinstance(y, list):
    print('list')
else:
    print('nope')
	
O / P :

x is (1, 'two', 3.0, [4, 'four'], 5)                                                                                  
140203163542016                                                                                                       
140203162941752                                                                                                       
10105088                                                                                                              
10105088                                                                                                              
yep

##########################################

30. If you try to access a key that doesn't exist you'll get a key error exception so
if I say print animals sub Godzilla you notice that I get the exception of key error
Godzilla because that key does not exist. Or you can use the get method to return a value
when you don't know if the key exists. I can instead say animals.get like that and I get the
none value because that key doesn't exist so if you don't want the exception, you want just
a none value, you can use the get method. So Python's dictionary type is both simple and
useful.

31. I've defined two different sets and I've defined them just using strings and when I run
this you'll notice using my print_set function below that what I get is an unordered list of
the unique characters in each string. There's no duplicates because a set does not allow
duplicates. And the lists are unordered, each time I run it you'll notice they come up in
a different order.

32. In Python, everything is an object and variables store references to objects. 

33. So let's take a look at the class constructor.
There's a special class method name called init, with double underscores before and after,
so those are two underscore characters. One and two, both before and after the word init.
And that's a special name for a class function which operates as an initializer, or a constructor.
And so you pass it three arguments, of course the first argument is always self, and that's what
makes it a method, an object method, because this self points at the object.
And then the three parameters type, name, and sound. And those are used to initialize object variables.
And these are object variables because they're never initialized until after the object is defined,
so they don't exist in the class without having been constructed into an object. And you notice that
the object variables all have an underscore at the beginning of the name. Again, this is traditional,
and this discourages users of the object from accessing these variables directly. Instead, you have
these accessors, or getters, I call them getters, some people call them accessors.
Which simply return the value of those object variables. 

34. Now you'll also notice this special method called str, with two underscores before and two underscores after. We've seen this before, in our constructor init, with two underscores before and two underscores after. So this is a specially-named method, which provides the string representation of the object. And this allows us to print it with simply this print and the object like that, without needing a special function, like we had in the previous lessons. You can find a list of all the special method names here in the documentation, under data model. And if you click on special method names, you'll see a whole bunch of them, with all of their descriptions. And there's str right there, the informal or nicely printable string representation of an object. And there's just a lot more of them. There's all the comparison operators, and this list goes on for quite a while. Methods are the primary interface for classes and objects. They work exactly like functions, except they are bound to the object through their first argument, commonly named self.

35. So it's important to understand the distinction between class variables and object variables and how to properly encapsulate data in your objects.

36. Iterator objects

37. it's important to note here that a string is immutable, it cannot be changed. So when you use one of these transformation methods, the return string is a different object.

38.
In long string consisting of digits and dashes, how would you replace all dashes with spaces?
split on dashes and join on spaces

39. 
Question 2 of 3
What will the following code print?
 

a=1
b=-1
print('{1:<+04} {0:+04}'.format(a,b))

Correct answer:
-100 +001

40.
You are given two strings: s1='Test' and s2='tEST'. Which of the following conditions will be false?

You are correct!
s1.title()==s2

41. A little bit about the open function here, by default, it opens the file in read-only mode,
which would be the same as providing a mode with a R letter.

42. On line 10, I close the out file, and this is important because again, buffering, all of what we've written to the file may not be completely written by the time our main function ends, and we want to prevent any data loss, so it's a good idea to close the file explicitly that you've written to. You can also the close the infile. I can say, infile.close, and this is less important because you're not going to really lose any data, and it will be closed automatically when we exit the main function. So now I'm going to run this. You notice it happens very quickly.

43. Your environment has very limited memory. How will you prefer to copy a file of an unknown size and content in this case?

You are correct!
Use small buffers over many iterations.

44. Question 2 of 3
How can you easily check if all items in a tuple are zeros?

You are correct!
Use an any() function.

45. The expression divmod(15,2) will return a _____ with a value of _____.
tuple; (7,1)

46. How can the following line of code be useful when you're planning to use your script as a module?
 

if __name__ == '__main__':    main()

You are correct!
It allows you to test your script when running it as a stand-alone program.

47.  The Python db api is a consolidated interface for a number of database systems. It's important to understand that every database engine has its own interface, its own requirements, and really its own paradigm, so no single interface will ever serve all of them equally.
