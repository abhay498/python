Coding guidelines and respective tools with respect Python 3.6 and above versions
----------------------------------------------------------------------------------------------------------------

1. Code formatter - autopep8, yapf
2. Pylint
•	Make sure to run pylint on your code.
•	pylint is a tool for finding bugs and style problems in Python source code.
•	pylint isn’t perfect. To take advantage of it, we’ll need to sometimes: 
    	  a) Write around it 
  b) Suppress its warnings or 
  c) Improve it.
•	https://pypi.org/project/pylint/
•	To suppress warnings, you can set a line-level comment:
   	   dict = 'something awful'  # Bad Idea... pylint: disable=redefined-builtin
•	You can get a list of pylint warnings by doing:
   	   pylint --list-msgs
•	To get more information on a particular message, use:
   	   pylint --help-msg=C6409
•	Prefer pylint: disable to the deprecated older form pylint: disable-msg.
   
3. Using Imports
•	Use import statements for packages and modules only, not for individual classes or functions. 
•	Use import x for importing packages and modules.
•	Use from x import y where x is the package prefix and y is the module name with no prefix.
•	Use from x import y as z if two modules named y are to be imported or if y is an inconveniently long name.
•	Use import y as z only when z is a standard abbreviation (e.g., np for numpy).   
•	Do not use relative names in imports. Even if the module is in the same package, use the full package name. This helps prevent unintentionally importing a package twice.
4. Packages
•	Import each module using the full pathname location of the module.
•	All new code should import each module by its full package name.
•	Imports should be as follows
•	Yes:
# Reference absl.flags in code with the complete name (verbose).
import absl.flags
from doctor.who import jodie

FLAGS = absl.flags.FLAGS
# Reference flags in code with just the module name (common).
from absl import flags
from doctor.who import jodie

       FLAGS = flags.FLAGS
•	No: (assume this file lives in doctor/who/ where jodie.py also exists)
# Unclear what module the author wanted and what will be imported.  The actual
# import behavior depends on external factors controlling sys.path.
# Which possible jodie module did the author intend to import?
import jodie

4. Exceptions
•	Raise exceptions like this: raise MyError('Error message') or raise MyError() .Do not use the two-argument form ( raise MyError, 'Error message' ).
•	Make use of built-in exception classes when it makes sense. For example, raise a ValueError to indicate a programming mistake like a violated precondition (such as if you were passed a negative number but required a positive one). Do not use assert statements for validating argument values of a public API. assert is used to ensure internal correctness, not to enforce correct usage nor to indicate that some unexpected event occurred. If an exception is desired in the latter cases, use a raise statement. 
•	Yes:
  def connect_to_next_port(self, minimum):
    """Connects to the next available port.

    Args:
      minimum: A port value greater or equal to 1024.

    Returns:
      The new minimum port.

    Raises:
      ConnectionError: If no available port is found.
    """
    if minimum < 1024:
      # Note that this raising of ValueError is not mentioned in the doc
      # string's "Raises:" section because it is not appropriate to
      # guarantee this specific behavioral reaction to API misuse.
      raise ValueError('Minimum port must be at least 1024, not %d.' % (minimum,))
    port = self._find_next_open_port(minimum)
    if not port:
      raise ConnectionError('Could not connect to service on %d or higher.' % (minimum,))
    assert port >= minimum, 'Unexpected port %d when minimum was %d.' % (port, minimum)
    return port
•	No:
  def connect_to_next_port(self, minimum):
    """Connects to the next available port.

    Args:
      minimum: A port value greater or equal to 1024.

    Returns:
      The new minimum port.
    """
    assert minimum >= 1024, 'Minimum port must be at least 1024.'
    port = self._find_next_open_port(minimum)
    assert port is not None
    return port

•	Libraries or packages may define their own exceptions. When doing so they must inherit from an existing exception class. Exception names should end in Error and should not introduce stutter (foo.FooError).
•	Never use catch-all except: statements, or catch Exception or StandardError, unless you are re-raising the exception, or creating an isolation point in the program where exceptions are not propagated but are recorded and suppressed instead, such as protecting a thread from crashing by guarding its outermost block.Python is very tolerant in this regard and except: will really catch everything including misspelled names, sys.exit() calls, Ctrl+C interrupts, unittest failures and all kinds of other exceptions that you simply don’t want to catch.
•	Minimize the amount of code in a try/except block. The larger the body of the try, the more likely that an exception will be raised by a line of code that you didn’t expect to raise an exception. In those cases, the try/except block hides a real error.
•	Use the finally clause to execute code whether or not an exception is raised in the try block. This is often useful for cleanup, i.e., closing a file.
•	When capturing an exception, use as rather than a comma. For example:
	try:
	  raise Error()
	except Error as error:
	  pass
  
5. 
5. Global variables  
•	Avoid global variables. Has the potential to change module behavior during the import, because assignments to global variables are done when the module is first imported.
•	While they are technically variables, module-level constants are permitted and encouraged. For example: MAX_HOLY_HANDGRENADE_COUNT = 3. Constants must be named using all caps with underscores.
•	If needed, globals should be declared at the module level and made internal to the module by prepending an _ to the name. External access must be done through public module-level functions.
6. Nested/Local/Inner Classes and Functions
•	Nested local functions or classes are fine when used to close over a local variable. Inner classes are fine.
•	A class can be defined inside of a method, function, or class. 
•	Nesting can make your outer function longer and less readable.
•	They are fine with some caveats. Avoid nested functions or classes except when closing over a local value. Do not nest a function just to hide it from users of a module. Instead, prefix its name with an _ at the module level so that it can still be accessed by tests.
7. Comprehensions & Generator Expressions
•	List, Dict, and Set comprehensions as well as generator expressions are okay to use for simple cases. Each portion must fit on one line: mapping expression, for clause, filter expression. Multiple for clauses or filter expressions are not permitted. Use loops instead when things get more complicated.
•	Yes:
  result = [mapping_expr for value in iterable if filter_expr]

  result = [{'key': value} for value in iterable
            if a_long_filter_expression(value)]

  result = [complicated_transform(x)
            for x in iterable if predicate(x)]

  descriptive_name = [
      transform({'key': key, 'value': value}, color='black')
      for key, value in generate_iterable(some_input)
      if complicated_condition_is_met(key, value)
  ]

  result = []
  for x in range(10):
      for y in range(5):
          if x * y > 10:
              result.append((x, y))

  return {x: complicated_transform(x)
          for x in long_generator_function(parameter)
          if x is not None}

  squares_generator = (x**2 for x in range(10))

  unique_names = {user.name for user in users if user is not None}

  eat(jelly_bean for jelly_bean in jelly_beans
      if jelly_bean.color == 'black')

•	No:
  result = [complicated_transform(
                x, some_argument=x+1)
            for x in iterable if predicate(x)]

  result = [(x, y) for x in range(10) for y in range(5) if x * y > 10]

  return ((x, y, z)
          for x in range(5)
          for y in range(5)
          if x != y
          for z in range(5)
          if y != z)
8.   Default Iterators and Operators
•	Use default iterators and operators for types that support them, like lists, dictionaries, and files. The built-in types define iterator methods, too. Prefer these methods to methods that return lists, except that you should not mutate a container while iterating over it. Never use Python 2 specific iteration methods such as dict.iter*() unless necessary.
•	Yes:  for key in adict: ...
      	if key not in adict: ...
      	if obj in alist: ...
      	for line in afile: ...
      	for k, v in adict.items(): ...
      	for k, v in six.iteritems(adict): ...

•	No:   for key in adict.keys(): ...
      	if not adict.has_key(key): ...
      	for line in afile.readlines(): ...
      	for k, v in dict.iteritems(): ...
9. Generators
•	Use generators as needed.   
•	A generator function returns an iterator that yields a value each time it executes a yield statement. After it yields a value, the runtime state of the generator function is suspended until the next value is needed.
•	Pros : Simpler code, because the state of local variables and control flow are preserved for each call. A generator uses less memory than a function that creates an entire list of values at once.
•	Cons: None
•	Fine. Use “Yields:” rather than “Returns:” in the docstring for generator functions.

10. Lambda Functions
•	Okay to use them for one-liners. If the code inside the lambda function is longer than 60-80 chars, it’s probably better to define it    as a regular nested function.
•	For common operations like multiplication, use the functions from the operator module instead of lambda functions. For example, prefer operator.mul to lambda x, y: x * y.
11. Conditional Expressions 
•	Conditional expressions (sometimes called a “ternary operator”) are mechanisms that provide a shorter syntax for if statements. For example: x = 1 if cond else 2.
•	Okay to use for simple cases. Each portion must fit on one line: true-expression, if-expression, else-expression. Use a complete if statement when things get more complicated.

•	one_line = 'yes' if predicate(value) else 'no'
•	slightly_split = ('yes' if predicate(value)
                  else 'no, nein, nyet')
•	the_longest_ternary_style_that_can_be_done = (
    'yes, true, affirmative, confirmed, correct'
    if predicate(value)
    else 'no, false, negative, nay')
•	bad_line_breaking = ('yes' if predicate(value) else
                     'no')
•	portion_too_long = ('yes'
                    if some_long_module.some_long_predicate_function(
                        really_long_variable_name)
                    else 'no, false, negative, nay')
		    
12.  Default Argument Values
•	Cons : Default arguments are evaluated once at module load time. This may cause problems if the argument is a mutable object such as a list or a dictionary. If the function modifies the object (e.g., by appending an item to a list), the default value is modified.
•	Okay to use with the following caveat:
	Do not use mutable objects as default values in the function or method definition.
Yes: def foo(a, b=None):
        if b is None:
            b = []
Yes: def foo(a, b: Optional[Sequence] = None):
        if b is None:
            b = []
Yes: def foo(a, b: Sequence = ()):  # Empty tuple OK since tuples are immutable
        ...

No:  def foo(a, b=[]):
        ...
No:  def foo(a, b=time.time()):  # The time the module was loaded???
        ...
No:  def foo(a, b=FLAGS.my_thing):  # sys.argv has not yet been parsed...
        ...
No:  def foo(a, b: Mapping = {}):  # Could still get passed to unchecked code
        ...

13. Properties
•	Use properties for accessing or setting data where you would normally have used simple, lightweight accessor or setter methods.
•	A way to wrap method calls for getting and setting an attribute as a standard attribute access when the computation is lightweight.
•	Use properties in new code to access or set data where you would normally have used simple, lightweight accessor or setter methods. Properties should be created with the @property decorator.
•	Inheritance with properties can be non-obvious if the property itself is not overridden. Thus one must make sure that accessor methods are called indirectly to ensure methods overridden in subclasses are called by the property (using the Template Method DP).
Yes: import math

     class Square(object):
         """A square with two properties: a writable area and a read-only perimeter.

         To use:
         >>> sq = Square(3)
         >>> sq.area
         9
         >>> sq.perimeter
         12
         >>> sq.area = 16
         >>> sq.side
         4
         >>> sq.perimeter
         16
         """

         def __init__(self, side):
             self.side = side

         @property
         def area(self):
             """Area of the square."""
             return self._get_area()

         @area.setter
         def area(self, area):
             return self._set_area(area)

         def _get_area(self):
             """Indirect accessor to calculate the 'area' property."""
             return self.side ** 2

         def _set_area(self, area):
             """Indirect setter to set the 'area' property."""
             self.side = math.sqrt(area)

         @property
         def perimeter(self):
             return self.side * 4
14. True/False Evaluations
•	Use the “implicit” false if at all possible.
•	Python evaluates certain values as False when in a boolean context. A quick “rule of thumb” is that all “empty” values are considered false, so 0, None, [], {}, '' all evaluate as false in a boolean context.
•	Use the “implicit” false if possible, e.g., if foo: rather than if foo != []:. There are a few caveats that you should keep in mind though:
•	Always use if foo is None: (or is not None) to check for a None value-e.g., when testing whether a variable or argument that defaults to None was set to some other value. The other value might be a value that’s false in a boolean context!
•	Never compare a boolean variable to False using ==. Use if not x: instead. If you need to distinguish False from None then chain the expressions, such as if not x and x is not None:.
•	For sequences (strings, lists, tuples), use the fact that empty sequences are false, so if seq: and if not seq: are preferable to if len(seq): and if not len(seq): respectively.
•	When handling integers, implicit false may involve more risk than benefit (i.e., accidentally handling None as 0). You may compare a value which is known to be an integer (and is not the result of len()) against the integer 0.

•	Yes: if not users:
         print('no users')

     if foo == 0:
         self.handle_zero()

     if i % 10 == 0:
         self.handle_multiple_of_ten()

     def f(x=None):
         if x is None:
             x = []
•	No:  if len(users) == 0:
         print('no users')

     if foo is not None and not foo:
         self.handle_zero()

     if not i % 10:
         self.handle_multiple_of_ten()

     def f(x=None):
         x = x or []
•	Note that '0' (i.e., 0 as string) evaluates to true.
15. Deprecated Language Features
•	Use string methods instead of the string module where possible.
•	Use function call syntax instead of apply.
•	Use list comprehensions and for loops instead of filter and map when the function argument would have been an inlined lambda anyway. 
•	Use for loops instead of reduce.
•	Yes: words = foo.split(':')

     [x[1] for x in my_list if x[2] == 5]

     map(math.sqrt, data)    # Ok. No inlined lambda expression.

     fn(*args, **kwargs)
•	No:  words = string.split(foo, ':')

     map(lambda x: x[1], filter(lambda x: x[2] == 5, my_list))

     apply(fn, args, kwargs)

16.  Lexical Scoping
•	A nested Python function can refer to variables defined in enclosing functions, but can not assign to them.Variable bindings are resolved using lexical scoping, that is, based on the static program text. Any assignment to a name in a block will cause Python to treat all references to that name as a local variable, even if the use precedes the assignment. If a global declaration occurs, the name is treated as a global variable. It is okay to use Lexical scoping.

•	An example of the use of this feature is:
def get_adder(summand1):
    """Returns a function that adds numbers to a given number."""
    def adder(summand2):
        return summand1 + summand2

    return adder
•	i = 4
def foo(x):
    def bar():
        print(i, end='')
    # ...
    # A bunch of code here
    # ...
    for i in x:  # Ah, i *is* local to foo, so this is what bar sees
        print(i, end='')
    bar()
So foo([1, 2, 3]) will print 1 2 3 3, not 1 2 3 4.
17. Function and Method Decorators
•	Use decorators judiciously when there is a clear advantage.
•	Avoid @staticmethod and limit use of @classmethod.
•	Specifically, for some function my_decorator, this:
class C(object):
    @my_decorator
    def method(self):
        # method body ...
is equivalent to
class C(object):
    def method(self):
        # method body ...
    method = my_decorator(method)
•	Pros : Elegantly specifies some transformation on a method; the transformation might eliminate some repetitive code, enforce invariants, etc.
•	Cons:
1.	Decorators can perform arbitrary operations on a function’s arguments or return values, resulting in surprising implicit behavior.
2.	Additionally, decorators execute at import time. Failures in decorator code are pretty much impossible to recover from.
•	Never use @staticmethod unless forced to in order to integrate with an API defined in an existing library. Write a module level function instead.
•	Use @classmethod only when writing a named constructor or a class-specific routine that modifies necessary global state such as a process-wide cache.
18. Threading
•	Do not rely on the atomicity of built-in types.
•	While Python’s built-in data types such as dictionaries appear to have atomic operations, there are corner cases where they aren’t atomic (e.g. if __hash__ or __eq__ are implemented as Python methods) and their atomicity should not be relied upon. Neither should you rely on atomic variable assignment (since this in turn depends on dictionaries).
•	Use the Queue module’s Queue data type as the preferred way to communicate data between threads. Otherwise, use the threading module and its locking primitives. Learn about the proper use of condition variables so you can use threading.Condition instead of using lower-level locks.

19.  Power Features
•	Avoid these features in your code.
•	Python is an extremely flexible language and gives you many fancy features such as custom metaclasses, access to bytecode, on-the-fly compilation, dynamic inheritance, object reparenting, import hacks, reflection (e.g. some uses of getattr()), modification of system internals, etc.
•	These are powerful language features. They can make your code more compact.
•	It’s very tempting to use these “cool” features when they’re not absolutely necessary. 
•	It’s harder to read, understand, and debug code that’s using unusual features underneath.
•	It doesn’t seem that way at first (to the original author), but when revisiting the code, it tends to be more difficult than code that is longer but is straightforward.
•	Standard library modules and classes that internally use these features are okay to use (for example, abc.ABCMeta, collections.namedtuple, dataclasses, and enum).

20. Type Annotated Code
•	You can annotate Python 3 code with type hints according to PEP-484, and type-check the code at build time with a type checking tool like pytype.
•	Type annotations can be in the source or in a stub pyi file. Whenever possible, annotations should be in the source. Use pyi files for third-party or extension modules.
•	Type annotations (or “type hints”) are for function or method arguments and return values:
def func(a: int) -> List[int]:
•	You can also declare the type of a variable using a special comment:
a = SomeFunc()  # type: SomeType

•	Type annotations improve the readability and maintainability of your code. The type checker will convert many runtime errors to build-time errors, and reduce your ability to use Power Features.
•	You will have to keep the type declarations up to date. You might see type errors that you think are valid code. Use of a type checker may reduce your ability to use Power Features.
•	You are strongly encouraged to enable Python type analysis when updating code. When adding or modifying public APIs, include type annotations and enable checking via pytype in the build system. As static analysis is relatively new to Python, we acknowledge that undesired side-effects (such as wrongly inferred types) may prevent adoption by some projects. In those situations, authors are encouraged to add a comment with a TODO or link to a bug describing the issue(s) currently preventing type annotation adoption in the BUILD file or in the code itself as appropriate.

21.    Do not terminate your lines with semicolons, and do not use semicolons to put two statements on the same line.
22. Line length
•	Maximum line length is 80 characters.
•	Explicit exceptions to the 80 character limit:
Long import statements.
URLs, pathnames, or long flags in comments.
Long string module level constants not containing whitespace that would be inconvenient to split across lines such as URLs or pathnames.
Pylint disable comments. (e.g.: # pylint: disable=invalid-name)
23. Do not use backslash line continuation except for with statements requiring three or more context managers.
24. When a literal string won’t fit on a single line, use parentheses for implicit line joining.
   x = ('This will build a very long long '
 'long long long long long long string')

25. Within comments, put long URLs on their own line if necessary.
Yes:  # See details at
      # http://www.example.com/us/developer/documentation/api/content/v2.0/csv_file_name_extension_full_specification.html
No:  # See details at
     # http://www.example.com/us/developer/documentation/api/content/\
     # v2.0/csv_file_name_extension_full_specification.html

26.  It is permissible to use backslash continuation when defining a with statement whose expressions span three or more lines. For two lines of expressions, use a nested with statement:

Yes:  with very_long_first_expression_function() as spam, \
           very_long_second_expression_function() as beans, \
           third_thing() as eggs:
          place_order(eggs, beans, spam, beans)
No:  with VeryLongFirstExpressionFunction() as spam, \
          VeryLongSecondExpressionFunction() as beans:
       PlaceOrder(eggs, beans, spam, beans)
Yes:  with very_long_first_expression_function() as spam:
          with very_long_second_expression_function() as beans:
              place_order(beans, spam)

27. Parentheses
•	Use parentheses sparingly.

•	Yes: if foo:
         bar()
     while x:
         x = bar()
     if x and y:
         bar()
     if not x:
         bar()
     # For a 1 item tuple the ()s are more visually obvious than the comma.
     onesie = (foo,)
     return foo
     return spam, beans
     return (spam, beans)
     for (x, y) in dict.items(): ...

•	No:  if (x):
         bar()
     if not(x):
         bar()
     return (foo)

28.  Indent your code blocks with 4 spaces.

•	Yes:   # Aligned with opening delimiter
       foo = long_function_name(var_one, var_two,
                                var_three, var_four)
       meal = (spam,
               beans)

       # Aligned with opening delimiter in a dictionary
       foo = {
           long_dictionary_key: value1 +
                                value2,
           ...
       }

       # 4-space hanging indent; nothing on first line
       foo = long_function_name(
           var_one, var_two, var_three,
           var_four)
       meal = (
           spam,
           beans)

       # 4-space hanging indent in a dictionary
       foo = {
           long_dictionary_key:
               long_dictionary_value,
           ...
       }

•	No:    # Stuff on first line forbidden
       foo = long_function_name(var_one, var_two,
           var_three, var_four)
       meal = (spam,
           beans)

       # 2-space hanging indent forbidden
       foo = long_function_name(
         var_one, var_two, var_three,
         var_four)

       # No hanging indent in a dictionary
       foo = {
           long_dictionary_key:
           long_dictionary_value,
           ...
       }

29.   Trailing commas in sequences of items are recommended only when the closing container token ], ), or } does not appear on the same line as the final element. 
•	Yes:   golomb3 = [0, 1, 3]
•	Yes:   golomb4 = [
           0,
           1,
           4,
           6,
       ]
•	No:    golomb4 = [
           0,
           1,
           4,
           6
       ]
30. Blank Lines
•	Two blank lines between top-level definitions, be they function or class definitions. 
•	One blank line between method definitions and between the class line and the first method. 
•	No blank line following a def line. Use single blank lines as you judge appropriate within functions or methods.
31. Whitespace
•	No whitespace inside parentheses, brackets or braces.
Yes: spam(ham[1], {eggs: 2}, [])
No:  spam( ham[ 1 ], { eggs: 2 }, [ ] )

•	No whitespace before a comma, semicolon, or colon. Do use whitespace after a comma, semicolon, or colon, except at the end of the line.
Yes: if x == 4:
         print(x, y)
     x, y = y, x
No:  if x == 4 :
         print(x , y)
     x , y = y , x
•	No whitespace before the open paren/bracket that starts an argument list, indexing or slicing.
Yes: spam(1)
No:  spam (1)
Yes: dict['key'] = list[index]
No:  dict ['key'] = list [index]

•	No trailing whitespace.
•	Surround binary operators with a single space on either side for assignment (=), comparisons (==, <, >, !=, <>, <=, >=, in, not in, is, is not), and Booleans (and, or, not). Use your better judgment for the insertion of spaces around arithmetic operators (+, -, *, /, //, %, **, @).
Yes: x == 1
No:  x<1
•	Never use spaces around = when passing keyword arguments or defining a default parameter value, with one exception: when a type annotation is present, do use spaces around the = for the default parameter value.
Yes: def complex(real, imag=0.0): return Magic(r=real, i=imag)
Yes: def complex(real, imag: float = 0.0): return Magic(r=real, i=imag)
No:  def complex(real, imag = 0.0): return Magic(r = real, i = imag)
No:  def complex(real, imag: float=0.0): return Magic(r = real, i = imag)

•	Don’t use spaces to vertically align tokens on consecutive lines, since it becomes a maintenance burden (applies to :, #, =, etc.):

Yes:
  foo = 1000  # comment
  long_name = 2  # comment that should not be aligned

  dictionary = {
      'foo': 1,
      'long_name': 2,
  }

No:
  foo       = 1000  # comment
  long_name = 2     # comment that should not be aligned

  dictionary = {
      'foo'      : 1,
      'long_name': 2,
  }
32.  Shebang Line
•	Most .py files do not need to start with a #! line. Start the main file of a program with #!/usr/bin/python with an optional single digit 2 or 3 suffix per PEP-394.
         This line is used by the kernel to find the Python interpreter, but is ignored by Python when importing modules. It is only necessary on a file that will be executed directly.
33. Comments and Docstrings
•	Docstrings
•	Python uses docstrings to document code. 
•	A docstring is a string that is the first statement in a package, module, class or function.
•	These strings can be extracted automatically through the __doc__ member of the object and are used by pydoc. (Try running pydoc on your module to see how it looks.)
•	Always use the three double-quote """ format for docstrings (per PEP 257).
•	A docstring should be organized as a summary line (one physical line) terminated by a period, question mark, or exclamation point, followed by a blank line, followed by the rest of the docstring starting at the same cursor position as the first quote of the first line. 
•	Every file should contain license boilerplate. Choose the appropriate boilerplate for the license used by the project (for example, Apache 2.0, BSD, LGPL, GPL)
•	Files should start with a docstring describing the contents and usage of the module.






"""A one line summary of the module or program, terminated by a period.

Leave one blank line.  The rest of this docstring should contain an
overall description of the module or program.  Optionally, it may also
contain a brief description of exported classes and functions and/or usage
examples.

  Typical usage example:

  foo = ClassFoo()
  bar = foo.FunctionBar()
"""
34. Functions and Methods
a.    A function must have a docstring, unless it meets all the following criteria:
•	not externally visible
•	very short
•	obvious
       b.    A docstring should give enough information to write a call to the function without reading the function’s code.
      c. The docstring should be descriptive-style ("""Fetches rows from a Bigtable.""") rather than imperative-style ("""Fetch rows from a Bigtable."""), except for @property data descriptors, which should use the same style as attributes. 
      d.  A docstring should describe the function’s calling syntax and its semantics, not its implementation.
     e.  For tricky code, comments alongside the code are more appropriate than using docstrings.
     f.  Certain aspects of a function should be documented in special sections, listed below. Each section begins with a heading line, which ends with a colon. All sections other than the heading should maintain a hanging indent of two or four spaces (be consistent within a file). These sections can be omitted in cases where the function’s name and signature are informative enough that it can be aptly described using a one-line docstring.
    g. 
Args:
List each parameter by name. A description should follow the name, and be separated by a colon and a space. If the description is too long to fit on a single 80-character line, use a hanging indent of 2 or 4 spaces (be consistent with the rest of the file).
The description should include required type(s) if the code does not contain a corresponding type annotation. If a function accepts *foo (variable length argument lists) and/or **bar (arbitrary keyword arguments), they should be listed as *foo and **bar.
Returns: (or Yields: for generators)
Describe the type and semantics of the return value. If the function only returns None, this section is not required. It may also be omitted if the docstring starts with Returns or Yields (e.g. """Returns row from Bigtable as a tuple of strings.""") and the opening sentence is sufficient to describe return value.
Raises:
List all exceptions that are relevant to the interface. You should not document exceptions that get raised if the API specified in the docstring is violated (because this would paradoxically make behavior under violation of the API part of the API).
def fetch_bigtable_rows(big_table, keys, other_silly_variable=None):
    """Fetches rows from a Bigtable.

    Retrieves rows pertaining to the given keys from the Table instance
    represented by big_table.  Silly things may happen if
    other_silly_variable is not None.

    Args:
        big_table: An open Bigtable Table instance.
        keys: A sequence of strings representing the key of each table row
            to fetch.
        other_silly_variable: Another optional variable, that has a much
            longer name than the other args, and which does nothing.

    Returns:
        A dict mapping keys to the corresponding table row data
        fetched. Each row is represented as a tuple of strings. For
        example:

        {'Serak': ('Rigel VII', 'Preparer'),
         'Zim': ('Irk', 'Invader'),
         'Lrrr': ('Omicron Persei 8', 'Emperor')}

        If a key from the keys argument is missing from the dictionary,
        then that row was not found in the table.

    Raises:
        IOError: An error occurred accessing the bigtable.Table object.
    """
  
h. Classes
•	Classes should have a docstring below the class definition describing the class. If your class has public attributes, they should be documented here in an Attributes section and follow the same formatting as a function’s Args section.
•	
class SampleClass(object):
    """Summary of class here.

    Longer class information....
    Longer class information....

    Attributes:
        likes_spam: A boolean indicating if we like SPAM or not.
        eggs: An integer count of the eggs we have laid.
    """

    def __init__(self, likes_spam=False):
        """Inits SampleClass with blah."""
        self.likes_spam = likes_spam
        self.eggs = 0

    def public_method(self):
        """Performs operation blah."""
i.	Block and Inline Comments

•	The final place to have comments is in tricky parts of the code.
•	If you’re going to have to explain it at the next code review, you should comment it now. Complicated operations get a few lines of comments before the operations commence. Non-obvious ones get comments at the end of the line.
# We use a weighted dictionary search to find out where i is in
# the array.  We extrapolate position based on the largest num
# in the array and the array size and then do binary search to
# get the exact number.

if i & (i-1) == 0:  # True if i is 0 or a power of 2.

•	To improve legibility, these comments should start at least 2 spaces away from the code with the comment character #, followed by at least one space before the text of the comment itself.

•	On the other hand, never describe the code. Assume the person reading the code knows Python (though not what you’re trying to do) better than you do.
# BAD COMMENT: Now go through the b array and make sure whenever i occurs
# the next element is i+1

•	Although, it can be frustrating to have a code reviewer point out that you are using a comma when you should be using a semicolon, it is very important that source code maintain a high level of clarity and readability. Proper punctuation, spelling, and grammar help with that goal.

•	If a class inherits from no other base classes, explicitly inherit from object. This also applies to nested classes.

•	Yes: 

     class SampleClass(object):
         pass


     class OuterClass(object):

         class InnerClass(object):
             pass


     class ChildClass(ParentClass):
         """Explicitly inherits from another class already."""

No: class SampleClass:
        pass


    class OuterClass:

        class InnerClass:
            pass

•	Inheriting from object is needed to make properties work properly in Python 2 and can protect your code from potential incompatibility with Python 3. It also defines special methods that implement the default semantics of objects including __new__, __init__, __delattr__, __getattribute__, __setattr__, __hash__, __repr__, and __str__.

35. Strings
•	Use the format method or the % operator for formatting strings, even when the parameters are all strings.
•	Use your best judgment to decide between + and % (or format) though.

•	Yes: x = a + b
     x = '%s, %s!' % (imperative, expletive)
     x = '{}, {}'.format(first, second)
     x = 'name: %s; score: %d' % (name, n)
     x = 'name: {}; score: {}'.format(name, n)
     x = f'name: {name}; score: {n}'  # Python 3.6+

No: x = '%s%s' % (a, b)  # use + in this case
    x = '{}{}'.format(a, b)  # use + in this case
    x = first + ', ' + second
    x = 'name: ' + name + '; score: ' + str(n)
•	Avoid using the + and += operators to accumulate a string within a loop. Since strings are immutable, this creates unnecessary temporary objects and results in quadratic rather than linear running time. Instead, add each substring to a list and ''.join the list after the loop terminates (or, write each substring to a io.BytesIO buffer).

•	Yes: items = ['<table>']
     for last_name, first_name in employee_list:
         items.append('<tr><td>%s, %s</td></tr>' % (last_name, first_name))
     items.append('</table>')
     employee_table = ''.join(items)
No: employee_table = '<table>'
    for last_name, first_name in employee_list:
        employee_table += '<tr><td>%s, %s</td></tr>' % (last_name, first_name)
    employee_table += '</table>'

•	Be consistent with your choice of string quote character within a file. Pick ' or " and stick with it. It is okay to use the other quote character on a string to avoid the need to \\ escape within the string.

•	Yes:
  	Python('Why are you hiding your eyes?')
	Gollum("I'm scared of lint errors.")
        Narrator('"Good!" thought a happy Python reviewer.')
       No:
	Python("Why are you hiding your eyes?")
  	Gollum('The lint. It burns. It burns us.')
	Gollum("Always the great lint. Watching. Watching.")
•	Prefer """ for multi-line strings rather than '''.
•	Docstrings must use """ regardless.
•	Multi-line strings do not flow with the indentation of the rest of the program. If you need to avoid embedding extra space in the string, use either concatenated single-line strings or a multi-line string with textwrap.dedent() to remove the initial space on each line:

•	No:
  long_string = """This is pretty ugly.
Don't do this.
"""
•	Yes:
  long_string = """This is fine if your use case can accept
      extraneous leading spaces."""
•	Yes:
  long_string = ("And this is fine if you can not accept\n" +
                 "extraneous leading spaces.")
•	Yes:
  long_string = ("And this too is fine if you can not accept\n"
                 "extraneous leading spaces.")
•	Yes:
  import textwrap

  long_string = textwrap.dedent("""\
      This is also fine, because textwrap.dedent()
      will collapse common leading spaces in each line.""")



36. Files and Sockets
•	Explicitly close files and sockets when done with them.
Leaving files, sockets or other file-like objects open unnecessarily has many downsides:
•	They may consume limited system resources, such as file descriptors. Code that deals with many such objects may exhaust those resources unnecessarily if they’re not returned to the system promptly after use.
•	Holding files open may prevent other actions such as moving or deleting them.
•	Files and sockets that are shared throughout a program may inadvertently be read from or written to after logically being closed. If they are actually closed, attempts to read or write from them will throw exceptions, making the problem known sooner.

•	The preferred way to manage files is using the “with” statement:
with open("hello.txt") as hello_file:
    for line in hello_file:
        print(line)
•	For file-like objects that do not support the “with” statement, use contextlib.closing():
import contextlib

with contextlib.closing(urllib.urlopen("http://www.python.org/")) as front_page:
    for line in front_page:
        print(line)
37. TODO
•	Use TODO comments for code that is temporary, a short-term solution, or good-enough but not perfect.
•	# TODO(kl@gmail.com): Use a "*" here for string repetition.
   # TODO(Zeke) Change this to use relations.
38.  Imports formatting
•	Imports should be on separate lines.
•	Yes: import os
            import sys
No:  import os, sys
•	Imports should be grouped from most generic to least generic:
•	Within each grouping, imports should be sorted lexicographically, ignoring case, according to each module’s full package path. Code may optionally place a blank line between import sections.

•	Example

import collections
import queue
import sys

from absl import app
from absl import flags
import bs4
import cryptography
import tensorflow as tf

from book.genres import scifi
from myproject.backend.hgwells import time_machine
from myproject.backend.state_machine import main_loop
from otherproject.ai import body
from otherproject.ai import mind
from otherproject.ai import soul

# Older style code may have these imports down here instead:
#from myproject.backend.hgwells import time_machine
#from myproject.backend.state_machine import main_loop

39. Statements
Yes:

  if foo: bar(foo)  # no else statement here
No:

  if foo: bar(foo)
  else:   baz(foo)

  try:               bar(foo)
  except ValueError: baz(foo)

  try:
      bar(foo)
  except ValueError: baz(foo)

40. Naming
•	module_name, package_name, ClassName, method_name, ExceptionName, function_name, GLOBAL_CONSTANT_NAME, global_var_name, instance_var_name, function_parameter_name, local_var_name.
Function names, variable names, and filenames should be descriptive; eschew abbreviation. In particular, do not use abbreviations that are ambiguous or unfamiliar to readers outside your project, and do not abbreviate by deleting letters within a word.
41. Names to Avoid
•	single character names except for counters or iterators. You may use “e” as an exception identifier in try/except statements.
•	dashes (-) in any package/module name
•	__double_leading_and_trailing_underscore__ names (reserved by Python)
42. Python filenames must have a .py extension and must not contain dashes (-). 
43. Guidelines derived from Guido’s Recommendations

Type	Public	Internal
Packages	lower_with_under	
Modules	lower_with_under	_lower_with_under
Classes	CapWords	_CapWords
Exceptions	CapWords	
Functions	lower_with_under()	_lower_with_under()
Global/Class Constants	CAPS_WITH_UNDER	_CAPS_WITH_UNDER
Global/Class Variables	lower_with_under	_lower_with_under
Instance Variables	lower_with_under	_lower_with_under (protected)
Method Names	lower_with_under()	_lower_with_under() (protected)
Function/Method Parameters	lower_with_under	
Local Variables	lower_with_under	

44. While Python supports making things private by using a leading double underscore __ (aka. “dunder”) prefix on a name, this is discouraged. Prefer the use of a single underscore. They are easier to type, read, and to access from small unittests. Lint warnings take care of invalid access to protected members.

45. Function length
•	Prefer small and focused functions.
•	We recognize that long functions are sometimes appropriate, so no hard limit is placed on function length. If a function exceeds about 40 lines, think about whether it can be broken up without harming the structure of the program. Even if your long function works perfectly now, someone modifying it in a few months may add new behavior. This could result in bugs that are hard to find. Keeping your functions short and simple makes it easier for other people to read and modify your code.
•	You could find long and complicated functions when working with some code. Do not be intimidated by modifying existing code: if working with such a function proves to be difficult, you find that errors are hard to debug, or you want to use a piece of it in several different contexts, consider breaking up the function into smaller and more manageable pieces.

46. Type Annotations
•	Familiarize yourself with PEP-484.

47.  BE CONSISTENT.
•	If you’re editing code, take a few minutes to look at the code around you and determine its style. If they use spaces around all their arithmetic operators, you should too. If their comments have little boxes of hash marks around them, make your comments have little boxes of hash marks around them too.

•	The point of having style guidelines is to have a common vocabulary of coding so people can concentrate on what you’re saying rather than on how you’re saying it. We present global style rules here, so people know the vocabulary, but local style is also important. If code you add to a file looks drastically different from the existing code around it, it throws readers out of their rhythm when they go to read it. Avoid this.
48. When to use is and == in python ?
    https://stackoverflow.com/questions/6570371/when-to-use-and-when-to-use-is

49. https://pybit.es/faster-python.html
    Time complexities and space complexities.
    
50. https://medium.com/humans-create-software/how-do-i-learn-to-write-simpler-more-efficient-code-with-fewer-lines-da0fe693146e
    
51. https://stackabuse.com/big-o-notation-and-algorithm-analysis-with-python-examples/
# END


