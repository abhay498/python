Coding guidelines and respective tools with respect Python 3.0 and above versions
------------------------------------------------------------------------------------------

1. Code formatter - autopep8, yapf

2. Make sure you run pylint on your code.

3. Using Imports
   a. Use import x for importing packages and modules.
   b. Use from x import y where x is the package prefix and y is the module name with no prefix.
   c. Use from x import y as z if two modules named y are to be imported or if y is an inconveniently long name.
   d. Use import y as z only when z is a standard abbreviation (e.g., np for numpy).   
   e. Do not use relative names in imports. Even if the module is in the same package, use the full package name. This helps prevent      	unintentionally importing a package twice.

4. Exceptions
   a. Raise exceptions like this: raise MyError('Error message') or raise MyError() .
      Do not use the two-argument form ( raise MyError, 'Error message' ).
   b. Make use of built-in exception classes when it makes sense. For example, raise a ValueError to indicate a programming mistake like       a violated precondition (such as if you were passed a negative number but required a positive one). Do not use assert statements         for validating argument values of a public API. assert is used to ensure internal correctness, not to enforce correct usage nor to       indicate that some unexpected event occurred. If an exception is desired in the latter cases, use a raise statement. 
   c. Libraries or packages may define their own exceptions. When doing so they must inherit from an existing exception class. Exception       names should end in Error and should not introduce stutter (foo.FooError).
   d. Never use catch-all except: statements, or catch Exception or StandardError, unless you are re-raising the exception, or
      creating an isolation point in the program where exceptions are not propagated but are recorded and suppressed instead, such as         protecting a thread from crashing by guarding its outermost block.
      Python is very tolerant in this regard and except: will really catch everything including misspelled names, sys.exit() calls,           Ctrl+C interrupts, unittest failures and all kinds of other exceptions that you simply don’t want to catch.
   e. Minimize the amount of code in a try/except block. The larger the body of the try, the more likely that an exception will be             raised by a line of code that you didn’t expect to raise an exception. In those cases, the try/except block hides a real error.
   f. Use the finally clause to execute code whether or not an exception is raised in the try block. This is often useful for cleanup,         i.e., closing a file.

      When capturing an exception, use as rather than a comma. For example:
      
	try:
	  raise Error()
	except Error as error:
	  pass
  
5. Avoid global variables.Has the potential to change module behavior during the import, because assignments to global variables are        done when the module is first imported.

6. List, Set and Dictionary Comprehensions & Generator Expressions
   Okay to use for simple cases. Each portion must fit on one line: mapping expression, for clause, filter expression. Multiple for
   clauses or filter expressions are not permitted. Use loops instead when things get more complicated.

7. Generators
   A generator function returns an iterator that yields a value each time it executes a yield statement. After it yields a value, the      runtime state of the generator function is suspended until the next value is needed.

8. Okay to use them for one-liners. If the code inside the lambda function is longer than 60-80 chars, it’s probably better to define it    as a regular nested function.
   For common operations like multiplication, use the functions from the operator module instead of lambda functions. For example,          prefer operator.mul to lambda x, y: x * y.

9. Conditional Expressions [ Okay for simple cases ]

Okay to use for simple cases. Each portion must fit on one line: true-expression, if-expression, else-expression. Use a complete if statement when things get more complicated.

one_line = 'yes' if predicate(value) else 'no'
slightly_split = ('yes' if predicate(value)
                  else 'no, nein, nyet')
the_longest_ternary_style_that_can_be_done = (
    'yes, true, affirmative, confirmed, correct'
    if predicate(value)
    else 'no, false, negative, nay')
bad_line_breaking = ('yes' if predicate(value) else
                     'no')
portion_too_long = ('yes'
                    if some_long_module.some_long_predicate_function(
                        really_long_variable_name)
                    else 'no, false, negative, nay')
		    
10. 


8. Imports should be on separate lines.

9. Be consistent with your choice of string quote character within a file. Pick ' or " and stick with it.

10. Prefer """ for multi-line strings rather than ''' . Projects may choose to use ''' for all non-docstring multi-line strings if and only if they also use ' for regular strings.
	Docstrings must use """ regardless.

11. If a class inherits from no other base classes, explicitly inherit from object . This also applies to nested classes.

12. Classes should have a docstring below the class definition describing the class. If your class has public attributes,
	they should be documented here in an Attributes section

13. List all exceptions that are relevant to the interface.

14. The docstring should be descriptive ( """Fetches rows from a Bigtable.""" ) rather than
	imperative ( """Fetch rows from a Bigtable.""" ). A docstring should describe the
	function’s calling syntax and its semantics, not its implementation. For tricky code,
	comments alongside the code are more appropriate than using docstrings. 
 
15. Parantheses -> Use parentheses sparingly.
	It is fine, though not required, to use parentheses around tuples. Do not use them in return statements or conditional statements
	unless using parentheses for implied line continuation or to indicate a tuple.

16. Use of from __future__ import statements is encouraged. All new code should contain the following and existing code should be updated to be compatible when possible:
	from __future__ import absolute_import from __future__ import division from __future__ import print_function

17. Use the “implicit” false if at all possible, e.g., if foo: rather than if foo != []: .
    There are a few caveats that you should keep in mind though: Never use == or != to compare singletons like None . Use is or is not . Beware of writing if x: when you really mean if x is not None: -e.g., when testing whether a variable or argument that defaults to None was set to some other value. The other value might be a value that’s false in a boolean context! Never compare a boolean variable to False using == . Use if not x: instead. If you need to distinguish False from None then chain the expressions, such as if not x and x is not None: . For sequences (strings, lists, tuples), use the fact that empty sequences are false, so if seq: and if not seq: are preferable to if len(seq): and if not len(seq): respectively. When handling integers, implicit false may involve more risk than benefit (i.e., accidentally handling None as 0). You may compare a value which is known to be an integer (and is not the result of len() ) against the integer 0.

18. When to use is and == in python ?
    https://stackoverflow.com/questions/6570371/when-to-use-and-when-to-use-is

19. https://pybit.es/faster-python.html
    Time complexities and space complexities.
    
20. https://medium.com/humans-create-software/how-do-i-learn-to-write-simpler-more-efficient-code-with-fewer-lines-da0fe693146e
    
21. https://stackabuse.com/big-o-notation-and-algorithm-analysis-with-python-examples/

22. Function length
    Prefer small and focused functions.

    a. We recognize that long functions are sometimes appropriate, so no hard limit is placed on function length. If a function exceeds        about 40 lines, think about whether it can be broken up without harming the structure of the program.

    b. Even if your long function works perfectly now, someone modifying it in a few months may add new behavior. This could result in  bugs that are hard to find. Keeping your functions short and simple makes it easier for other people to read and modify your code.

    c. You could find long and complicated functions when working with some code. Do not be intimidated by modifying existing code: if  working with such a function proves to be difficult, you find that errors are hard to debug, or you want to use a piece of it in  several different contexts, consider breaking up the function into smaller and more manageable pieces.

