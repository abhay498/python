Coding guidelines and respective tools with respect Python 3.6 and above versions
----------------------------------------------------------------------------------------------------------------

1. Code formatter - autopep8, yapf
2. Pylint
•	Make sure to run pylint on your code.
•	pylint is a tool for finding bugs and style problems in Python source code.
•	pylint isn’t perfect. To take advantage of it, we’ll need to sometimes: 
    	  a) Write around it 
  b) Suppress its warnings or 
  c) Improve it.
•	https://pypi.org/project/pylint/
•	To suppress warnings, you can set a line-level comment:
   	   dict = 'something awful'  # Bad Idea... pylint: disable=redefined-builtin
•	You can get a list of pylint warnings by doing:
   	   pylint --list-msgs
•	To get more information on a particular message, use:
   	   pylint --help-msg=C6409
•	Prefer pylint: disable to the deprecated older form pylint: disable-msg.
   
3. Using Imports
•	Use import statements for packages and modules only, not for individual classes or functions. 
•	Use import x for importing packages and modules.
•	Use from x import y where x is the package prefix and y is the module name with no prefix.
•	Use from x import y as z if two modules named y are to be imported or if y is an inconveniently long name.
•	Use import y as z only when z is a standard abbreviation (e.g., np for numpy).   
•	Do not use relative names in imports. Even if the module is in the same package, use the full package name. This helps prevent unintentionally importing a package twice.
4. Packages
•	Import each module using the full pathname location of the module.
•	All new code should import each module by its full package name.
•	Imports should be as follows
•	Yes:
# Reference absl.flags in code with the complete name (verbose).
import absl.flags
from doctor.who import jodie

FLAGS = absl.flags.FLAGS
# Reference flags in code with just the module name (common).
from absl import flags
from doctor.who import jodie

       FLAGS = flags.FLAGS
•	No: (assume this file lives in doctor/who/ where jodie.py also exists)
# Unclear what module the author wanted and what will be imported.  The actual
# import behavior depends on external factors controlling sys.path.
# Which possible jodie module did the author intend to import?
import jodie

4. Exceptions
•	Raise exceptions like this: raise MyError('Error message') or raise MyError() .Do not use the two-argument form ( raise MyError, 'Error message' ).
•	Make use of built-in exception classes when it makes sense. For example, raise a ValueError to indicate a programming mistake like a violated precondition (such as if you were passed a negative number but required a positive one). Do not use assert statements for validating argument values of a public API. assert is used to ensure internal correctness, not to enforce correct usage nor to indicate that some unexpected event occurred. If an exception is desired in the latter cases, use a raise statement. 
•	Yes:
  def connect_to_next_port(self, minimum):
    """Connects to the next available port.

    Args:
      minimum: A port value greater or equal to 1024.

    Returns:
      The new minimum port.

    Raises:
      ConnectionError: If no available port is found.
    """
    if minimum < 1024:
      # Note that this raising of ValueError is not mentioned in the doc
      # string's "Raises:" section because it is not appropriate to
      # guarantee this specific behavioral reaction to API misuse.
      raise ValueError('Minimum port must be at least 1024, not %d.' % (minimum,))
    port = self._find_next_open_port(minimum)
    if not port:
      raise ConnectionError('Could not connect to service on %d or higher.' % (minimum,))
    assert port >= minimum, 'Unexpected port %d when minimum was %d.' % (port, minimum)
    return port
•	No:
  def connect_to_next_port(self, minimum):
    """Connects to the next available port.

    Args:
      minimum: A port value greater or equal to 1024.

    Returns:
      The new minimum port.
    """
    assert minimum >= 1024, 'Minimum port must be at least 1024.'
    port = self._find_next_open_port(minimum)
    assert port is not None
    return port

•	Libraries or packages may define their own exceptions. When doing so they must inherit from an existing exception class. Exception names should end in Error and should not introduce stutter (foo.FooError).
•	Never use catch-all except: statements, or catch Exception or StandardError, unless you are re-raising the exception, or creating an isolation point in the program where exceptions are not propagated but are recorded and suppressed instead, such as protecting a thread from crashing by guarding its outermost block.Python is very tolerant in this regard and except: will really catch everything including misspelled names, sys.exit() calls, Ctrl+C interrupts, unittest failures and all kinds of other exceptions that you simply don’t want to catch.
•	Minimize the amount of code in a try/except block. The larger the body of the try, the more likely that an exception will be raised by a line of code that you didn’t expect to raise an exception. In those cases, the try/except block hides a real error.
•	Use the finally clause to execute code whether or not an exception is raised in the try block. This is often useful for cleanup, i.e., closing a file.
•	When capturing an exception, use as rather than a comma. For example:
	try:
	  raise Error()
	except Error as error:
	  pass
  
5. 
5. Global variables  
•	Avoid global variables. Has the potential to change module behavior during the import, because assignments to global variables are done when the module is first imported.
•	While they are technically variables, module-level constants are permitted and encouraged. For example: MAX_HOLY_HANDGRENADE_COUNT = 3. Constants must be named using all caps with underscores.
•	If needed, globals should be declared at the module level and made internal to the module by prepending an _ to the name. External access must be done through public module-level functions.
6. Nested/Local/Inner Classes and Functions
•	Nested local functions or classes are fine when used to close over a local variable. Inner classes are fine.
•	A class can be defined inside of a method, function, or class. 
•	Nesting can make your outer function longer and less readable.
•	They are fine with some caveats. Avoid nested functions or classes except when closing over a local value. Do not nest a function just to hide it from users of a module. Instead, prefix its name with an _ at the module level so that it can still be accessed by tests.
7. Comprehensions & Generator Expressions
•	List, Dict, and Set comprehensions as well as generator expressions are okay to use for simple cases. Each portion must fit on one line: mapping expression, for clause, filter expression. Multiple for clauses or filter expressions are not permitted. Use loops instead when things get more complicated.
•	Yes:
  result = [mapping_expr for value in iterable if filter_expr]

  result = [{'key': value} for value in iterable
            if a_long_filter_expression(value)]

  result = [complicated_transform(x)
            for x in iterable if predicate(x)]

  descriptive_name = [
      transform({'key': key, 'value': value}, color='black')
      for key, value in generate_iterable(some_input)
      if complicated_condition_is_met(key, value)
  ]

  result = []
  for x in range(10):
      for y in range(5):
          if x * y > 10:
              result.append((x, y))

  return {x: complicated_transform(x)
          for x in long_generator_function(parameter)
          if x is not None}

  squares_generator = (x**2 for x in range(10))

  unique_names = {user.name for user in users if user is not None}

  eat(jelly_bean for jelly_bean in jelly_beans
      if jelly_bean.color == 'black')

•	No:
  result = [complicated_transform(
                x, some_argument=x+1)
            for x in iterable if predicate(x)]

  result = [(x, y) for x in range(10) for y in range(5) if x * y > 10]

  return ((x, y, z)
          for x in range(5)
          for y in range(5)
          if x != y
          for z in range(5)
          if y != z)
8.   Default Iterators and Operators
•	Use default iterators and operators for types that support them, like lists, dictionaries, and files. The built-in types define iterator methods, too. Prefer these methods to methods that return lists, except that you should not mutate a container while iterating over it. Never use Python 2 specific iteration methods such as dict.iter*() unless necessary.
•	Yes:  for key in adict: ...
      	if key not in adict: ...
      	if obj in alist: ...
      	for line in afile: ...
      	for k, v in adict.items(): ...
      	for k, v in six.iteritems(adict): ...

•	No:   for key in adict.keys(): ...
      	if not adict.has_key(key): ...
      	for line in afile.readlines(): ...
      	for k, v in dict.iteritems(): ...
9. Generators
•	Use generators as needed.   
•	A generator function returns an iterator that yields a value each time it executes a yield statement. After it yields a value, the runtime state of the generator function is suspended until the next value is needed.
•	Pros : Simpler code, because the state of local variables and control flow are preserved for each call. A generator uses less memory than a function that creates an entire list of values at once.
•	Cons: None
•	Fine. Use “Yields:” rather than “Returns:” in the docstring for generator functions.

10. Lambda Functions
•	Okay to use them for one-liners. If the code inside the lambda function is longer than 60-80 chars, it’s probably better to define it    as a regular nested function.
•	For common operations like multiplication, use the functions from the operator module instead of lambda functions. For example, prefer operator.mul to lambda x, y: x * y.
11. Conditional Expressions 
•	Conditional expressions (sometimes called a “ternary operator”) are mechanisms that provide a shorter syntax for if statements. For example: x = 1 if cond else 2.
•	Okay to use for simple cases. Each portion must fit on one line: true-expression, if-expression, else-expression. Use a complete if statement when things get more complicated.

•	one_line = 'yes' if predicate(value) else 'no'
•	slightly_split = ('yes' if predicate(value)
                  else 'no, nein, nyet')
•	the_longest_ternary_style_that_can_be_done = (
    'yes, true, affirmative, confirmed, correct'
    if predicate(value)
    else 'no, false, negative, nay')
•	bad_line_breaking = ('yes' if predicate(value) else
                     'no')
•	portion_too_long = ('yes'
                    if some_long_module.some_long_predicate_function(
                        really_long_variable_name)
                    else 'no, false, negative, nay')
		    
12.  Default Argument Values
•	Cons : Default arguments are evaluated once at module load time. This may cause problems if the argument is a mutable object such as a list or a dictionary. If the function modifies the object (e.g., by appending an item to a list), the default value is modified.
•	Okay to use with the following caveat:
	Do not use mutable objects as default values in the function or method definition.
Yes: def foo(a, b=None):
        if b is None:
            b = []
Yes: def foo(a, b: Optional[Sequence] = None):
        if b is None:
            b = []
Yes: def foo(a, b: Sequence = ()):  # Empty tuple OK since tuples are immutable
        ...

No:  def foo(a, b=[]):
        ...
No:  def foo(a, b=time.time()):  # The time the module was loaded???
        ...
No:  def foo(a, b=FLAGS.my_thing):  # sys.argv has not yet been parsed...
        ...
No:  def foo(a, b: Mapping = {}):  # Could still get passed to unchecked code
        ...

13. Properties
•	Use properties for accessing or setting data where you would normally have used simple, lightweight accessor or setter methods.
•	A way to wrap method calls for getting and setting an attribute as a standard attribute access when the computation is lightweight.
•	Use properties in new code to access or set data where you would normally have used simple, lightweight accessor or setter methods. Properties should be created with the @property decorator.
•	Inheritance with properties can be non-obvious if the property itself is not overridden. Thus one must make sure that accessor methods are called indirectly to ensure methods overridden in subclasses are called by the property (using the Template Method DP).
Yes: import math

     class Square(object):
         """A square with two properties: a writable area and a read-only perimeter.

         To use:
         >>> sq = Square(3)
         >>> sq.area
         9
         >>> sq.perimeter
         12
         >>> sq.area = 16
         >>> sq.side
         4
         >>> sq.perimeter
         16
         """

         def __init__(self, side):
             self.side = side

         @property
         def area(self):
             """Area of the square."""
             return self._get_area()

         @area.setter
         def area(self, area):
             return self._set_area(area)

         def _get_area(self):
             """Indirect accessor to calculate the 'area' property."""
             return self.side ** 2

         def _set_area(self, area):
             """Indirect setter to set the 'area' property."""
             self.side = math.sqrt(area)

         @property
         def perimeter(self):
             return self.side * 4
14. True/False Evaluations
•	Use the “implicit” false if at all possible.
•	Python evaluates certain values as False when in a boolean context. A quick “rule of thumb” is that all “empty” values are considered false, so 0, None, [], {}, '' all evaluate as false in a boolean context.
•	Use the “implicit” false if possible, e.g., if foo: rather than if foo != []:. There are a few caveats that you should keep in mind though:
•	Always use if foo is None: (or is not None) to check for a None value-e.g., when testing whether a variable or argument that defaults to None was set to some other value. The other value might be a value that’s false in a boolean context!
•	Never compare a boolean variable to False using ==. Use if not x: instead. If you need to distinguish False from None then chain the expressions, such as if not x and x is not None:.
•	For sequences (strings, lists, tuples), use the fact that empty sequences are false, so if seq: and if not seq: are preferable to if len(seq): and if not len(seq): respectively.
•	When handling integers, implicit false may involve more risk than benefit (i.e., accidentally handling None as 0). You may compare a value which is known to be an integer (and is not the result of len()) against the integer 0.

•	Yes: if not users:
         print('no users')

     if foo == 0:
         self.handle_zero()

     if i % 10 == 0:
         self.handle_multiple_of_ten()

     def f(x=None):
         if x is None:
             x = []
•	No:  if len(users) == 0:
         print('no users')

     if foo is not None and not foo:
         self.handle_zero()

     if not i % 10:
         self.handle_multiple_of_ten()

     def f(x=None):
         x = x or []
•	Note that '0' (i.e., 0 as string) evaluates to true.
15. Deprecated Language Features
•	Use string methods instead of the string module where possible.
•	Use function call syntax instead of apply.
•	Use list comprehensions and for loops instead of filter and map when the function argument would have been an inlined lambda anyway. 
•	Use for loops instead of reduce.
•	Yes: words = foo.split(':')

     [x[1] for x in my_list if x[2] == 5]

     map(math.sqrt, data)    # Ok. No inlined lambda expression.

     fn(*args, **kwargs)
•	No:  words = string.split(foo, ':')

     map(lambda x: x[1], filter(lambda x: x[2] == 5, my_list))

     apply(fn, args, kwargs)

16.  Lexical Scoping
•	A nested Python function can refer to variables defined in enclosing functions, but can not assign to them.Variable bindings are resolved using lexical scoping, that is, based on the static program text. Any assignment to a name in a block will cause Python to treat all references to that name as a local variable, even if the use precedes the assignment. If a global declaration occurs, the name is treated as a global variable. It is okay to use Lexical scoping.

•	An example of the use of this feature is:
def get_adder(summand1):
    """Returns a function that adds numbers to a given number."""
    def adder(summand2):
        return summand1 + summand2

    return adder
•	i = 4
def foo(x):
    def bar():
        print(i, end='')
    # ...
    # A bunch of code here
    # ...
    for i in x:  # Ah, i *is* local to foo, so this is what bar sees
        print(i, end='')
    bar()
So foo([1, 2, 3]) will print 1 2 3 3, not 1 2 3 4.
17. Function and Method Decorators
•	Use decorators judiciously when there is a clear advantage.
•	Avoid @staticmethod and limit use of @classmethod.
•	Specifically, for some function my_decorator, this:
class C(object):
    @my_decorator
    def method(self):
        # method body ...
is equivalent to
class C(object):
    def method(self):
        # method body ...
    method = my_decorator(method)
•	Pros : Elegantly specifies some transformation on a method; the transformation might eliminate some repetitive code, enforce invariants, etc.
•	Cons:
1.	Decorators can perform arbitrary operations on a function’s arguments or return values, resulting in surprising implicit behavior.
2.	Additionally, decorators execute at import time. Failures in decorator code are pretty much impossible to recover from.
•	Never use @staticmethod unless forced to in order to integrate with an API defined in an existing library. Write a module level function instead.
•	Use @classmethod only when writing a named constructor or a class-specific routine that modifies necessary global state such as a process-wide cache.
18. Threading
•	Do not rely on the atomicity of built-in types.
•	While Python’s built-in data types such as dictionaries appear to have atomic operations, there are corner cases where they aren’t atomic (e.g. if __hash__ or __eq__ are implemented as Python methods) and their atomicity should not be relied upon. Neither should you rely on atomic variable assignment (since this in turn depends on dictionaries).
•	Use the Queue module’s Queue data type as the preferred way to communicate data between threads. Otherwise, use the threading module and its locking primitives. Learn about the proper use of condition variables so you can use threading.Condition instead of using lower-level locks.






### Till here ###

13.  Imports should be on separate lines.

9. Be consistent with your choice of string quote character within a file. Pick ' or " and stick with it.

10. Prefer """ for multi-line strings rather than ''' . Projects may choose to use ''' for all non-docstring multi-line strings if and only if they also use ' for regular strings.
	Docstrings must use """ regardless.

11. If a class inherits from no other base classes, explicitly inherit from object . This also applies to nested classes.

12. Classes should have a docstring below the class definition describing the class. If your class has public attributes,
	they should be documented here in an Attributes section

13. List all exceptions that are relevant to the interface.

14. The docstring should be descriptive ( """Fetches rows from a Bigtable.""" ) rather than
	imperative ( """Fetch rows from a Bigtable.""" ). A docstring should describe the
	function’s calling syntax and its semantics, not its implementation. For tricky code,
	comments alongside the code are more appropriate than using docstrings. 
 
15. Parantheses -> Use parentheses sparingly.
	It is fine, though not required, to use parentheses around tuples. Do not use them in return statements or conditional statements
	unless using parentheses for implied line continuation or to indicate a tuple.

16. Use of from __future__ import statements is encouraged. All new code should contain the following and existing code should be updated to be compatible when possible:
	from __future__ import absolute_import from __future__ import division from __future__ import print_function

18. When to use is and == in python ?
    https://stackoverflow.com/questions/6570371/when-to-use-and-when-to-use-is

19. https://pybit.es/faster-python.html
    Time complexities and space complexities.
    
20. https://medium.com/humans-create-software/how-do-i-learn-to-write-simpler-more-efficient-code-with-fewer-lines-da0fe693146e
    
21. https://stackabuse.com/big-o-notation-and-algorithm-analysis-with-python-examples/

22. Function length
    Prefer small and focused functions.

    a. We recognize that long functions are sometimes appropriate, so no hard limit is placed on function length. If a function exceeds        about 40 lines, think about whether it can be broken up without harming the structure of the program.

    b. Even if your long function works perfectly now, someone modifying it in a few months may add new behavior. This could result in  bugs that are hard to find. Keeping your functions short and simple makes it easier for other people to read and modify your code.

    c. You could find long and complicated functions when working with some code. Do not be intimidated by modifying existing code: if  working with such a function proves to be difficult, you find that errors are hard to debug, or you want to use a piece of it in  several different contexts, consider breaking up the function into smaller and more manageable pieces.

