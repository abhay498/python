Coding guidelines and respective tools with respect Python 3.6 and above versions
----------------------------------------------------------------------------------------------------------------

1. Code formatter - autopep8, yapf
2. Pylint
•	Make sure to run pylint on your code.
•	pylint is a tool for finding bugs and style problems in Python source code.
•	pylint isn’t perfect. To take advantage of it, we’ll need to sometimes: 
    	  a) Write around it 
  b) Suppress its warnings or 
  c) Improve it.
•	https://pypi.org/project/pylint/
•	To suppress warnings, you can set a line-level comment:
   	   dict = 'something awful'  # Bad Idea... pylint: disable=redefined-builtin
•	You can get a list of pylint warnings by doing:
   	   pylint --list-msgs
•	To get more information on a particular message, use:
   	   pylint --help-msg=C6409
•	Prefer pylint: disable to the deprecated older form pylint: disable-msg.
   
3. Using Imports
•	Use import statements for packages and modules only, not for individual classes or functions. 
•	Use import x for importing packages and modules.
•	Use from x import y where x is the package prefix and y is the module name with no prefix.
•	Use from x import y as z if two modules named y are to be imported or if y is an inconveniently long name.
•	Use import y as z only when z is a standard abbreviation (e.g., np for numpy).   
•	Do not use relative names in imports. Even if the module is in the same package, use the full package name. This helps prevent unintentionally importing a package twice.
4. Packages
•	Import each module using the full pathname location of the module.
•	All new code should import each module by its full package name.
•	Imports should be as follows
•	Yes:
# Reference absl.flags in code with the complete name (verbose).
import absl.flags
from doctor.who import jodie

FLAGS = absl.flags.FLAGS
# Reference flags in code with just the module name (common).
from absl import flags
from doctor.who import jodie

       FLAGS = flags.FLAGS
•	No: (assume this file lives in doctor/who/ where jodie.py also exists)
# Unclear what module the author wanted and what will be imported.  The actual
# import behavior depends on external factors controlling sys.path.
# Which possible jodie module did the author intend to import?
import jodie

4. Exceptions
•	Raise exceptions like this: raise MyError('Error message') or raise MyError() .Do not use the two-argument form ( raise MyError, 'Error message' ).
•	Make use of built-in exception classes when it makes sense. For example, raise a ValueError to indicate a programming mistake like a violated precondition (such as if you were passed a negative number but required a positive one). Do not use assert statements for validating argument values of a public API. assert is used to ensure internal correctness, not to enforce correct usage nor to indicate that some unexpected event occurred. If an exception is desired in the latter cases, use a raise statement. 
•	Yes:
  def connect_to_next_port(self, minimum):
    """Connects to the next available port.

    Args:
      minimum: A port value greater or equal to 1024.

    Returns:
      The new minimum port.

    Raises:
      ConnectionError: If no available port is found.
    """
    if minimum < 1024:
      # Note that this raising of ValueError is not mentioned in the doc
      # string's "Raises:" section because it is not appropriate to
      # guarantee this specific behavioral reaction to API misuse.
      raise ValueError('Minimum port must be at least 1024, not %d.' % (minimum,))
    port = self._find_next_open_port(minimum)
    if not port:
      raise ConnectionError('Could not connect to service on %d or higher.' % (minimum,))
    assert port >= minimum, 'Unexpected port %d when minimum was %d.' % (port, minimum)
    return port
•	No:
  def connect_to_next_port(self, minimum):
    """Connects to the next available port.

    Args:
      minimum: A port value greater or equal to 1024.

    Returns:
      The new minimum port.
    """
    assert minimum >= 1024, 'Minimum port must be at least 1024.'
    port = self._find_next_open_port(minimum)
    assert port is not None
    return port

•	Libraries or packages may define their own exceptions. When doing so they must inherit from an existing exception class. Exception names should end in Error and should not introduce stutter (foo.FooError).
•	Never use catch-all except: statements, or catch Exception or StandardError, unless you are re-raising the exception, or creating an isolation point in the program where exceptions are not propagated but are recorded and suppressed instead, such as protecting a thread from crashing by guarding its outermost block.Python is very tolerant in this regard and except: will really catch everything including misspelled names, sys.exit() calls, Ctrl+C interrupts, unittest failures and all kinds of other exceptions that you simply don’t want to catch.
•	Minimize the amount of code in a try/except block. The larger the body of the try, the more likely that an exception will be raised by a line of code that you didn’t expect to raise an exception. In those cases, the try/except block hides a real error.
•	Use the finally clause to execute code whether or not an exception is raised in the try block. This is often useful for cleanup, i.e., closing a file.
•	When capturing an exception, use as rather than a comma. For example:
	try:
	  raise Error()
	except Error as error:
	  pass
  
5. 
5. Global variables  
•	Avoid global variables. Has the potential to change module behavior during the import, because assignments to global variables are done when the module is first imported.
•	While they are technically variables, module-level constants are permitted and encouraged. For example: MAX_HOLY_HANDGRENADE_COUNT = 3. Constants must be named using all caps with underscores.
•	If needed, globals should be declared at the module level and made internal to the module by prepending an _ to the name. External access must be done through public module-level functions.
6. Nested/Local/Inner Classes and Functions
•	Nested local functions or classes are fine when used to close over a local variable. Inner classes are fine.
•	A class can be defined inside of a method, function, or class. 
•	Nesting can make your outer function longer and less readable.
•	They are fine with some caveats. Avoid nested functions or classes except when closing over a local value. Do not nest a function just to hide it from users of a module. Instead, prefix its name with an _ at the module level so that it can still be accessed by tests.
### Till here ###
6. List, Set and Dictionary Comprehensions & Generator Expressions
   Okay to use for simple cases. Each portion must fit on one line: mapping expression, for clause, filter expression. Multiple for
   clauses or filter expressions are not permitted. Use loops instead when things get more complicated.

7. Generators
   A generator function returns an iterator that yields a value each time it executes a yield statement. After it yields a value, the      runtime state of the generator function is suspended until the next value is needed.

8. Okay to use them for one-liners. If the code inside the lambda function is longer than 60-80 chars, it’s probably better to define it    as a regular nested function.
   For common operations like multiplication, use the functions from the operator module instead of lambda functions. For example,          prefer operator.mul to lambda x, y: x * y.

9. Conditional Expressions [ Okay for simple cases ]

Okay to use for simple cases. Each portion must fit on one line: true-expression, if-expression, else-expression. Use a complete if statement when things get more complicated.

one_line = 'yes' if predicate(value) else 'no'
slightly_split = ('yes' if predicate(value)
                  else 'no, nein, nyet')
the_longest_ternary_style_that_can_be_done = (
    'yes, true, affirmative, confirmed, correct'
    if predicate(value)
    else 'no, false, negative, nay')
bad_line_breaking = ('yes' if predicate(value) else
                     'no')
portion_too_long = ('yes'
                    if some_long_module.some_long_predicate_function(
                        really_long_variable_name)
                    else 'no, false, negative, nay')
		    
10. 


8. Imports should be on separate lines.

9. Be consistent with your choice of string quote character within a file. Pick ' or " and stick with it.

10. Prefer """ for multi-line strings rather than ''' . Projects may choose to use ''' for all non-docstring multi-line strings if and only if they also use ' for regular strings.
	Docstrings must use """ regardless.

11. If a class inherits from no other base classes, explicitly inherit from object . This also applies to nested classes.

12. Classes should have a docstring below the class definition describing the class. If your class has public attributes,
	they should be documented here in an Attributes section

13. List all exceptions that are relevant to the interface.

14. The docstring should be descriptive ( """Fetches rows from a Bigtable.""" ) rather than
	imperative ( """Fetch rows from a Bigtable.""" ). A docstring should describe the
	function’s calling syntax and its semantics, not its implementation. For tricky code,
	comments alongside the code are more appropriate than using docstrings. 
 
15. Parantheses -> Use parentheses sparingly.
	It is fine, though not required, to use parentheses around tuples. Do not use them in return statements or conditional statements
	unless using parentheses for implied line continuation or to indicate a tuple.

16. Use of from __future__ import statements is encouraged. All new code should contain the following and existing code should be updated to be compatible when possible:
	from __future__ import absolute_import from __future__ import division from __future__ import print_function

17. Use the “implicit” false if at all possible, e.g., if foo: rather than if foo != []: .
    There are a few caveats that you should keep in mind though: Never use == or != to compare singletons like None . Use is or is not . Beware of writing if x: when you really mean if x is not None: -e.g., when testing whether a variable or argument that defaults to None was set to some other value. The other value might be a value that’s false in a boolean context! Never compare a boolean variable to False using == . Use if not x: instead. If you need to distinguish False from None then chain the expressions, such as if not x and x is not None: . For sequences (strings, lists, tuples), use the fact that empty sequences are false, so if seq: and if not seq: are preferable to if len(seq): and if not len(seq): respectively. When handling integers, implicit false may involve more risk than benefit (i.e., accidentally handling None as 0). You may compare a value which is known to be an integer (and is not the result of len() ) against the integer 0.

18. When to use is and == in python ?
    https://stackoverflow.com/questions/6570371/when-to-use-and-when-to-use-is

19. https://pybit.es/faster-python.html
    Time complexities and space complexities.
    
20. https://medium.com/humans-create-software/how-do-i-learn-to-write-simpler-more-efficient-code-with-fewer-lines-da0fe693146e
    
21. https://stackabuse.com/big-o-notation-and-algorithm-analysis-with-python-examples/

22. Function length
    Prefer small and focused functions.

    a. We recognize that long functions are sometimes appropriate, so no hard limit is placed on function length. If a function exceeds        about 40 lines, think about whether it can be broken up without harming the structure of the program.

    b. Even if your long function works perfectly now, someone modifying it in a few months may add new behavior. This could result in  bugs that are hard to find. Keeping your functions short and simple makes it easier for other people to read and modify your code.

    c. You could find long and complicated functions when working with some code. Do not be intimidated by modifying existing code: if  working with such a function proves to be difficult, you find that errors are hard to debug, or you want to use a piece of it in  several different contexts, consider breaking up the function into smaller and more manageable pieces.

